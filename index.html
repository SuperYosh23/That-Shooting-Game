<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>That Shooting Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        /* Body base styles */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Tailwind gray-900 */
            color: #e2e8f0; /* Tailwind gray-300 */
            margin: 0;
            overflow: hidden; /* Prevent scrollbars from canvas */
            display: flex; /* Use flexbox for overall layout */
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            width: 100vw; /* Ensure body takes full viewport width */
            position: relative; /* For absolute positioning of gameContainer */
        }

        #gameContainer {
            position: absolute; /* Position absolutely to fill the background */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center; /* Center canvas vertically */
            background-color: #000; /* Canvas will be drawn over this, but good fallback */
            overflow: hidden; /* Ensure content is clipped */
            border-radius: 0; /* No border-radius on container, canvas is full screen */
            box-shadow: none; /* No shadow on container */
        }

        canvas {
            display: block;
            background-color: #000; /* Canvas background */
            width: 100%; /* Canvas fills its container */
            height: 100%; /* Canvas fills its container */
        }

        #uiContainer {
            position: absolute; /* Position UI over the canvas */
            top: 0;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            background: linear-gradient(to bottom, #2d3748, #1a202c); /* Gradient background */
            border-bottom: 1px solid #4a5568; /* Subtle border */
            box-shadow: 0 2px 5px rgba(0,0,0,0.2); /* Shadow for depth */
            z-index: 5; /* Ensure UI is above canvas */
        }

        #scoreBoard, #waveBoard {
            font-size: 1.25rem;
            font-weight: 700;
            color: #cbd5e0;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        #pauseButton, #settingsButtonInGame { /* Added settingsButtonInGame */
            padding: 0.5rem 1rem;
            font-size: 1rem;
            background: linear-gradient(to right, #63b3ed, #4299e1);
            color: white;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            font-weight: 600;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
            margin-right: 0.5rem; /* Space between buttons */
        }
        #pauseButton:hover, #settingsButtonInGame:hover {
            background: linear-gradient(to right, #4299e1, #3182ce);
            transform: translateY(-1px);
        }
        #pauseButton:active, #settingsButtonInGame:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        /* Message display (title screen, game over, pause, wave messages) */
        #messageDisplay {
            position: fixed; /* Always fixed to viewport */
            top: 0;
            left: 0;
            height: 100vh; /* Full viewport height */
            width: 300px; /* Fixed width for the panel */
            background-color: rgba(30, 41, 59, 0.95); /* Semi-transparent dark background */
            color: #e2e8f0;
            padding: 2rem;
            box-sizing: border-box; /* Include padding in width/height */
            display: flex;
            flex-direction: column;
            justify-content: center; /* Center content vertically */
            align-items: flex-start; /* Align content to the left */
            z-index: 10; /* Ensure it's on top of gameContainer and UI */
            box-shadow: 5px 0 15px rgba(0,0,0,0.5); /* Shadow on the right edge */
            border-right: 1px solid #4a5568; /* Subtle border on the right */
            text-align: left; /* Default text alignment for panel content */
        }

        #messageDisplay #messageText {
            font-size: 2.8rem; /* Larger title font */
            font-weight: 800;
            margin-bottom: 2rem;
            width: 100%;
            text-align: left; /* Align title text to left */
            line-height: 1.1; /* Adjust line height for multi-line titles */
        }

        #messageDisplay button {
            width: 100%; /* Make buttons fill the panel width */
            margin-top: 1rem;
            padding: 0.75rem 1.75rem;
            font-size: 1.1rem;
            background: linear-gradient(to right, #4299e1, #63b3ed);
            color: white;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            font-weight: 700;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        #messageDisplay button:hover {
            background: linear-gradient(to right, #3182ce, #4299e1);
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0,0,0,0.3);
        }
        #messageDisplay button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        /* Small overlay messages (pause, wave incoming) - these should be centered */
        #messageDisplay.overlay-message {
            position: absolute; /* Revert to absolute for centering within gameContainer */
            width: auto; /* Auto width for content */
            height: auto; /* Auto height for content */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 2.5rem 3rem;
            text-align: center; /* Center text for overlay messages */
            border-radius: 0.75rem;
            box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5);
            border: 1px solid #4a5568;
            background-color: rgba(30, 41, 59, 0.95);
        }
        #messageDisplay.overlay-message #messageText {
            font-size: 1.8rem; /* Smaller font for overlay messages */
            text-align: center;
            margin-bottom: 0; /* No margin for simple messages */
        }
        #messageDisplay.overlay-message button {
            display: none; /* Hide buttons for simple overlay messages like "Game Paused" */
        }


        .touch-controls {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 350px;
            z-index: 20;
            justify-content: space-between;
            align-items: center;
            gap: 1.5rem;
        }
        .touch-controls button {
            background: linear-gradient(to bottom, #4a5568, #2d3748);
            color: white;
            border: 2px solid #a0aec0;
            border-radius: 50%;
            width: 70px;
            height: 70px;
            font-size: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            box-shadow: 0 6px 10px rgba(0,0,0,0.4);
            transition: all 0.2s ease-in-out;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        .touch-controls button:active {
            background: linear-gradient(to bottom, #2d3748, #1a202c);
            transform: scale(0.9);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        @media (hover: none) and (pointer: coarse) {
            .touch-controls {
                display: flex;
            }
        }

        /* Shop specific styles */
        #shopDisplay {
            position: fixed; /* Keep it fixed for overlay behavior */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(30, 41, 59, 0.98);
            color: #e2e8f0;
            padding: 2.5rem 3rem;
            border-radius: 0.75rem;
            text-align: center;
            font-size: 1.3rem;
            z-index: 15;
            display: none;
            width: 85%;
            max-width: 450px;
            box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5);
            border: 1px solid #4a5568;
        }

        #shopDisplay h2 {
            font-size: 2.2rem;
            font-weight: bold;
            margin-bottom: 2rem;
            color: #a0aec0;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        #shopItemsContainer {
            display: flex;
            flex-direction: column;
            gap: 1.25rem;
        }

        .shop-item-button {
            background: linear-gradient(to right, #63b3ed, #4299e1);
            color: #1a202c;
            padding: 0.85rem 1.75rem;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            font-size: 1.2rem;
            font-weight: 700;
            transition: all 0.2s ease-in-out;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
        }

        .shop-item-button:hover {
            background: linear-gradient(to right, #4299e1, #3182ce);
            transform: translateY(-3px);
            box-shadow: 0 6px 8px rgba(0,0,0,0.3);
        }

        .shop-item-button:disabled {
            background: linear-gradient(to right, #718096, #5a67d8);
            cursor: not-allowed;
            opacity: 0.7;
            transform: none;
            box-shadow: none;
        }

        .shop-item-button .ml-4 {
            background: linear-gradient(to right, #48bb78, #38a169);
            color: white;
            padding: 0.6rem 1.2rem;
            border-radius: 0.4rem;
            font-size: 1rem;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .shop-item-button .ml-4:hover:enabled {
            background: linear-gradient(to right, #38a169, #2f855a);
            transform: translateY(-1px);
        }
        .shop-item-button .ml-4:active:enabled {
            transform: translateY(0);
        }

        #closeShopBtn {
            margin-top: 2.5rem;
            padding: 0.75rem 2.25rem;
            font-size: 1.1rem;
            background: linear-gradient(to right, #e53e3e, #c53030);
            color: white;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            font-weight: 700;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }

        #closeShopBtn:hover {
            background: linear-gradient(to right, #c53030, #9b2c2c);
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0,0,0,0.3);
        }
        #closeShopBtn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        /* Settings menu styles */
        #settingsDisplay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(30, 41, 59, 0.98);
            color: #e2e8f0;
            padding: 2.5rem 3rem;
            border-radius: 0.75rem;
            text-align: center;
            font-size: 1.3rem;
            z-index: 20; /* Higher z-index than shop */
            display: none;
            width: 85%;
            max-width: 450px;
            box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5);
            border: 1px solid #4a5568;
        }

        #settingsDisplay h2 {
            font-size: 2.2rem;
            font-weight: bold;
            margin-bottom: 2rem;
            color: #a0aec0;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            background-color: #4a5568; /* Slightly darker background for setting item */
            padding: 1rem 1.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .setting-item label {
            font-size: 1.1rem;
            font-weight: 600;
            color: #cbd5e0;
        }

        /* Toggle Switch Styling */
        .switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            -webkit-transition: .4s;
            transition: .4s;
            border-radius: 34px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            -webkit-transition: .4s;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #48bb78; /* Green when checked */
        }

        input:focus + .slider {
            box-shadow: 0 0 1px #48bb78;
        }

        input:checked + .slider:before {
            -webkit-transform: translateX(26px);
            -ms-transform: translateX(26px);
            transform: translateX(26px);
        }

        /* Rounded sliders */
        .slider.round {
            border-radius: 34px;
        }

        .slider.round:before {
            border-radius: 50%;
        }

        #closeSettingsBtn {
            margin-top: 2.5rem;
            padding: 0.75rem 2.25rem;
            font-size: 1.1rem;
            background: linear-gradient(to right, #e53e3e, #c53030);
            color: white;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            font-weight: 700;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }

        #closeSettingsBtn:hover {
            background: linear-gradient(to right, #c53030, #9b2c2c);
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0,0,0,0.3);
        }
        #closeSettingsBtn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        /* How To Play menu styles */
        #howToPlayDisplay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(30, 41, 59, 0.98);
            color: #e2e8f0;
            padding: 2.5rem 3rem;
            border-radius: 0.75rem;
            text-align: center;
            font-size: 1.3rem;
            z-index: 20; /* Higher z-index than shop */
            display: none;
            width: 85%;
            max-width: 450px;
            box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5);
            border: 1px solid #4a5568;
        }

        #howToPlayDisplay h2 {
            font-size: 2.2rem;
            font-weight: bold;
            margin-bottom: 1.5rem;
            color: #a0aec0;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        #howToPlayDisplay p {
            margin-bottom: 1rem;
            font-size: 1.1rem;
            line-height: 1.5;
            text-align: left;
        }

        #howToPlayDisplay button {
            margin-top: 2rem;
            padding: 0.75rem 2.25rem;
            font-size: 1.1rem;
            background: linear-gradient(to right, #4299e1, #63b3ed);
            color: white;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            font-weight: 700;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
            width: 100%;
        }

        #howToPlayDisplay button:hover {
            background: linear-gradient(to right, #3182ce, #4299e1);
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0,0,0,0.3);
        }
        #howToPlayDisplay button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }


        /* Credits and GitHub Icon styles */
        #credits {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-size: 0.9rem;
            color: #a0aec0;
            z-index: 10;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        #githubLink {
            position: absolute;
            bottom: 10px;
            right: 10px;
            font-size: 1.5rem;
            color: #a0aec0;
            z-index: 10;
            transition: color 0.2s ease-in-out;
        }

        #githubLink:hover {
            color: #e2e8f0;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>

        <div id="uiContainer" class="hidden">
            <div class="flex items-center">
                <button id="pauseButton" class="hidden">Pause</button>
                <button id="settingsButtonInGame" class="hidden">Settings</button>
            </div>
            <div id="scoreBoard">Score: 0</div>
            <div id="waveBoard">Wave: 1</div>
            <button id="shopButton" class="px-4 py-2 bg-purple-600 text-white rounded-md font-semibold hover:bg-purple-700 transition-colors">Shop</button>
            <div id="healthBarDisplay" class="w-32 h-6 bg-red-700 rounded-full overflow-hidden border-2 border-gray-400">
                <div id="currentHealthBar" class="h-full bg-green-500 transition-all duration-100 ease-out"></div>
            </div>
        </div>

        <div id="credits">
            <div>Made by SuperYosh23 and Google Gemini</div>
        </div>
        <a id="githubLink" href="https://github.com/SuperYosh23" target="_blank" aria-label="My GitHub Profile">
            <i class="fab fa-github"></i>
        </a>
    </div>

    <div id="messageDisplay">
        <p id="messageText"></p>
        <button id="startButton" class="hidden">Start Game</button>
        <button id="restartButton" class="hidden">Restart Game</button>
        <button id="howToPlayButtonTitle" class="hidden">How To Play</button>
        <button id="settingsButtonTitle" class="hidden">Settings</button>
    </div>

    <div id="shopDisplay" class="hidden">
        <h2>Shop</h2>
        <div id="shopItemsContainer">
        </div>
        <p class="mt-4 text-lg">Your Score: <span id="shopScore" class="font-bold text-yellow-300">0</span></p>
        <button id="closeShopBtn">Close Shop</button>
    </div>

    <div id="settingsDisplay" class="hidden">
        <h2>Settings</h2>
        <div class="setting-item">
            <label for="soundToggle">Sound Effects</label>
            <label class="switch">
                <input type="checkbox" id="soundToggle" checked>
                <span class="slider round"></span>
            </label>
        </div>
        <div class="setting-item">
            <label for="starsToggle">Background Stars</label>
            <label class="switch">
                <input type="checkbox" id="starsToggle" checked>
                <span class="slider round"></span>
            </label>
        </div>
        <button id="closeSettingsBtn">Close Settings</button>
    </div>

    <div id="howToPlayDisplay" class="hidden">
        <h2>How To Play</h2>
        <p><strong>Objective:</strong> Survive endless waves of alien enemies and defeat powerful bosses!</p>
        <p><strong>Movement:</strong> Use <strong>WASD</strong> or <strong>Arrow Keys</strong> to move your ship.</p>
        <p><strong>Aim & Shoot:</strong> Move your <strong>Mouse</strong> to aim, and <strong>Click</strong> or press <strong>Spacebar</strong> to shoot.</p>
        <p><strong>Shop:</strong> Spend points earned from defeating enemies to upgrade your ship. The shop opens between waves and after boss fights.</p>
        <p><strong>Health:</strong> Keep an eye on your health bar! Pick up health packs from the shop to restore health.</p>
        <p><strong>Pause:</strong> Press <strong>ESC</strong> to pause the game at any time.</p>
        <button id="closeHowToPlayBtn">Back to Title</button>
    </div>

    <div class="touch-controls">
        <button id="touchLeftBtn">â—€</button>
        <button id="touchShootBtn">ðŸ’¥</button>
        <button id="touchRightBtn">â–¶</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreBoard = document.getElementById('scoreBoard');
        const waveBoard = document.getElementById('waveBoard');
        const messageDisplay = document.getElementById('messageDisplay');
        const messageText = document.getElementById('messageText');
        const startButton = document.getElementById('startButton');
        const restartButton = document.getElementById('restartButton');
        const settingsButtonTitle = document.getElementById('settingsButtonTitle'); // New settings button for title screen
        const settingsButtonInGame = document.getElementById('settingsButtonInGame'); // New settings button for in-game UI
        const howToPlayButtonTitle = document.getElementById('howToPlayButtonTitle'); // New How To Play button

        const shopDisplay = document.getElementById('shopDisplay');
        const shopItemsContainer = document.getElementById('shopItemsContainer');
        const shopScoreDisplay = document.getElementById('shopScore');
        const closeShopBtn = document.getElementById('closeShopBtn');
        const shopButton = document.getElementById('shopButton');
        const pauseButton = document.getElementById('pauseButton');

        const settingsDisplay = document.getElementById('settingsDisplay'); // New settings display
        const soundToggle = document.getElementById('soundToggle'); // New sound toggle switch
        const starsToggle = document.getElementById('starsToggle'); // New stars toggle switch
        const closeSettingsBtn = document.getElementById('closeSettingsBtn'); // New close settings button

        const howToPlayDisplay = document.getElementById('howToPlayDisplay'); // New How To Play display
        const closeHowToPlayBtn = document.getElementById('closeHowToPlayBtn'); // New close How To Play button

        const touchLeftBtn = document.getElementById('touchLeftBtn');
        const touchRightBtn = document.getElementById('touchRightBtn');
        const touchShootBtn = document.getElementById('touchShootBtn');

        // New references for the health bar elements
        const healthBarDisplay = document.getElementById('healthBarDisplay');
        const currentHealthBar = document.getElementById('currentHealthBar');

        let gameWidth, gameHeight;

        let score = 0;
        let playerHealth = 75; // Changed playerHealth default to 75
        const playerMaxHealth = 75; // Changed playerMaxHealth to 75
        let wave = 1;
        let enemiesRequiredForWave = 15;
        let enemiesDefeatedInWave = 0;
        var wavesPerBoss = 5;
        let gameRunning = false;
        let shopOpen = false;
        let bossActive = false;
        let paused = false;
        let wasGameRunningBeforeShop = false;
        let wasGameRunningBeforeSettings = false; // New: to remember state before opening settings
        let wasGameRunningBeforeHowToPlay = false; // New: to remember state before opening how to play
        let soundEnabled = true; // New: sound state
        let starsEnabled = true; // New: stars state
        let settingsOpen = false; // New: Flag to track if settings menu is open
        let howToPlayOpen = false; // New: Flag to track if how to play menu is open
        let isTransitioningFromMenu = false; // Flag to prevent ghost clicks

        let animationFrameId;
        let titleAnimationId;

        let bossFightsCompleted = 0;
        const baseEnemySpeed = 2;
        const speedIncreasePerBoss = 1.0;
        const baseSpawnInterval = 1500;
        const spawnIntervalDecreasePerWave = 75;

        const mouse = {
            x: 0,
            y: 0,
            isOverCanvas: false
        };

        let MAX_AIM_DISTANCE = 250;
        const MAX_AIM_ANGLE_RADIANS = Math.PI / 6;

        const player = {
            x: 0,
            y: 0,
            width: 50,
            height: 50,
            color: '#4299e1',
            currentAngle: -Math.PI / 2,
            targetAngle: -Math.PI / 2,
            rotationSpeed: 1.0,
            dx: 0,
            dy: 0,
            initialY: 0,
            titleAnimationOffset: 0,
            titleAnimationDirection: 1,
            titleAnimationSpeed: 0.5,
            titleAnimationMaxOffset: 10,
            draw: function() {
                ctx.save();

                ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
                ctx.rotate(this.currentAngle + Math.PI / 2);

                const bodyGradient = ctx.createLinearGradient(-this.width / 2, -this.height / 2, this.width / 2, this.height / 2);
                bodyGradient.addColorStop(0, '#4299e1');
                bodyGradient.addColorStop(0.5, '#63b3ed');
                bodyGradient.addColorStop(1, '#4299e1');
                ctx.fillStyle = bodyGradient;

                ctx.beginPath();
                ctx.moveTo(0, -this.height / 2);
                ctx.lineTo(-this.width * 0.4, this.height * 0.2);
                ctx.lineTo(-this.width * 0.3, this.height / 2);
                ctx.lineTo(this.width * 0.3, this.height / 2);
                ctx.lineTo(this.width * 0.4, this.height * 0.2);
                ctx.closePath();
                ctx.fill();

                ctx.fillStyle = '#a78bfa';
                ctx.beginPath();
                ctx.arc(0, -this.height * 0.1, 8, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#f56565';
                ctx.fillRect(-this.width * 0.2, this.height / 2 - 5, this.width * 0.15, 10);
                ctx.fillRect(this.width * 0.05, this.height / 2 - 5, this.width * 0.15, 10);

                if (gameRunning) {
                    const exhaustHeight = Math.random() * 10 + 5;
                    const exhaustGradient = ctx.createLinearGradient(0, this.height / 2, 0, this.height / 2 + exhaustHeight);
                    exhaustGradient.addColorStop(0, 'rgba(255, 165, 0, 0.8)');
                    exhaustGradient.addColorStop(0.5, 'rgba(255, 255, 0, 0.5)');
                    exhaustGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    ctx.fillStyle = exhaustGradient;
                    ctx.beginPath();
                    ctx.moveTo(-this.width * 0.2, this.height / 2);
                    ctx.lineTo(-this.width * 0.3, this.height / 2 + exhaustHeight);
                    ctx.lineTo(this.width * 0.3, this.height / 2 + exhaustHeight);
                    ctx.lineTo(this.width * 0.2, this.height / 2);
                    ctx.closePath();
                    ctx.fill();
                }

                ctx.restore();
            },
            speed: 7,
        };

        const bullets = [];
        const bulletProps = {
            width: 5,
            height: 15,
            color: '#f56565',
            draw: function(bullet) {
                ctx.save();
                ctx.translate(bullet.x + this.width / 2, bullet.y + this.height / 2);
                ctx.rotate(bullet.angle + Math.PI / 2);

                ctx.fillStyle = this.color;
                ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                ctx.fillStyle = '#ff7777';
                ctx.fillRect(-this.width / 2 + 1, -this.height / 2 + 2, this.width - 2, this.height - 4);

                ctx.fillStyle = 'rgba(255, 200, 0, 0.5)';
                ctx.fillRect(-this.width / 2, this.height / 2, this.width, this.height * 0.5);

                ctx.restore();
            },
            speed: 10,
            cooldown: 250,
            lastShotTime: 0
        };

        const enemyTypes = [
            {
                name: 'small',
                width: 40,
                height: 30,
                health: 10,
                baseSpeed: baseEnemySpeed,
                colors: ['#48bb78', '#38a169', '#68d391'],
                canShoot: false,
                scoreValue: 10
            },
            {
                name: 'medium',
                width: 60,
                height: 45,
                health: 20,
                baseSpeed: baseEnemySpeed * 0.8,
                colors: ['#f6ad55', '#ed8936', '#dd6b20'],
                canShoot: true,
                bulletSpeed: 5,
                shootCooldown: 3000,
                scoreValue: 30
            },
            {
                name: 'large',
                width: 80,
                height: 60,
                health: 30,
                baseSpeed: baseEnemySpeed * 0.6,
                colors: ['#e53e3e', '#c53030', '#9b2c2c'],
                canShoot: true,
                bulletSpeed: 7,
                shootCooldown: 4000,
                scoreValue: 60
            }
        ];

        const enemies = [];
        const enemyProps = {
            spawnInterval: baseSpawnInterval,
            lastSpawnTime: 0
        };

        const enemyBullets = [];
        const enemyBulletProps = {
            width: 12,
            height: 12,
            color: '#FF0000',
            draw: function(bullet) {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, this.width / 2, 0, Math.PI * 2);
                ctx.fill();

                const gradient = ctx.createRadialGradient(bullet.x, bullet.y, 0, bullet.x, bullet.y, this.width / 2 + 5);
                gradient.addColorStop(0, 'rgba(255, 0, 0, 0.8)');
                gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, this.width / 2 + 5, 0, Math.PI * 2);
                ctx.fill();
            },
            damage: 10
        };

        const boss = {
            x: 0, y: 0, width: 0, height: 0,
            health: 0, maxHealth: 0,
            speed: 1, dx: 1,
            color: '#e53e3e',
            bulletSpeed: 6,
            shootCooldown: 1000,
            lastShotTime: 0,

            draw: function() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.moveTo(this.x + this.width * 0.1, this.y);
                ctx.lineTo(this.x + this.width * 0.9, this.y);
                ctx.lineTo(this.x + this.width, this.y + this.height * 0.5);
                ctx.lineTo(this.x + this.width * 0.9, this.y + this.height);
                ctx.lineTo(this.x + this.width * 0.1, this.y + this.height);
                ctx.lineTo(this.x, this.y + this.height * 0.5);
                ctx.closePath();
                ctx.fill();

                ctx.fillStyle = '#a0aec0';
                ctx.fillRect(this.x + this.width * 0.05, this.y + this.height * 0.3, 20, this.height * 0.4);
                ctx.fillRect(this.x + this.width * 0.95 - 20, this.y + this.height * 0.3, 20, this.height * 0.4);

                ctx.fillStyle = '#f6e05e';
                ctx.beginPath();
                ctx.arc(this.x + this.width / 2, this.y + this.height / 2, 30, 0, Math.PI * 2);
                ctx.fill();

                const healthBarWidth = this.width * 0.8;
                const healthBarHeight = 15;
                const healthBarX = this.x + (this.width - healthBarWidth) / 2;
                const healthBarY = this.y - 25;

                ctx.fillStyle = '#c53030';
                ctx.fillRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);

                const currentHealthWidth = (this.health / this.maxHealth) * healthBarWidth;
                ctx.fillStyle = '#48bb78';
                ctx.fillRect(healthBarX, healthBarY, currentHealthWidth, healthBarHeight);

                ctx.strokeStyle = '#e2e8f0';
                ctx.lineWidth = 1;
                ctx.strokeRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);
            }
        };

        const stars = [];
        const numStars = 150;

        const flashEffect = {
            active: false,
            color: 'rgba(255, 0, 0, 0.3)',
            duration: 200,
            startTime: 0
        };

        const aimIndicator = {
            x: 0,
            y: 0,
            radius: 8,
            color: '#FFFF00',
            draw: function() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius + 2, 0, Math.PI * 2);
                ctx.stroke();
            }
        };

        const shopItems = {
            'bulletSpeed': {
                id: 'bulletSpeed',
                name: 'Faster Bullets',
                baseCost: 100,
                currentLevel: 0,
                maxLevel: 3,
                effect: () => { bulletProps.speed += 2; },
                description: 'Increases bullet speed by 2.',
                getCost: function() { return Math.floor(this.baseCost * (1 + this.currentLevel * 0.5)); },
                getDisplayName: function() {
                    return this.currentLevel < this.maxLevel ?
                        `${this.name} (Lv.${this.currentLevel + 1})` :
                        `${this.name} (Max Lv.)`;
                }
            },
            'healthPack': {
                id: 'healthPack',
                name: 'Health Pack',
                baseCost: 200,
                currentLevel: 0,
                effect: () => { playerHealth = Math.min(playerMaxHealth, playerHealth + 50); updateHealthDisplay(); },
                description: 'Restores 50 health (max 100).',
                getCost: function() { return Math.floor(this.baseCost * (1 + this.currentLevel * 0.25)); },
                getDisplayName: function() { return this.name; }
            },
            'playerSpeed': {
                id: 'playerSpeed',
                name: 'Player Speed',
                baseCost: 150,
                currentLevel: 0,
                maxLevel: 2,
                effect: () => { player.speed += 1; },
                description: 'Increases player movement speed by 1.',
                getCost: function() { return Math.floor(this.baseCost * (1 + this.currentLevel * 0.75)); },
                getDisplayName: function() {
                    return this.currentLevel < this.maxLevel ?
                        `${this.name} (Lv.${this.currentLevel + 1})` :
                        `${this.name} (Max Lv.)`;
                }
            },
            'bulletRange': {
                id: 'bulletRange',
                name: 'Extended Range',
                baseCost: 120,
                currentLevel: 0,
                maxLevel: 3,
                effect: () => { MAX_AIM_DISTANCE += 50; },
                description: 'Increases bullet travel distance.',
                getCost: function() { return Math.floor(this.baseCost * (1 + this.currentLevel * 0.6)); },
                getDisplayName: function() {
                    return this.currentLevel < this.maxLevel ?
                        `${this.name} (Lv.${this.currentLevel + 1})` :
                        `${this.name} (Max Lv.)`;
                }
            }
        };

        // --- Tone.js Sound Effects ---
        const playerSynth = new Tone.Synth({
            oscillator: { type: "triangle" },
            envelope: {
                attack: 0.001,
                decay: 0.1,
                sustain: 0.05,
                release: 0.1
            },
            volume: -10
        }).toDestination();

        const enemySynth = new Tone.Synth({
            oscillator: { type: "sine" },
            envelope: {
                attack: 0.01,
                decay: 0.2,
                sustain: 0.05,
                release: 0.2
            },
            volume: -15
        }).toDestination();

        function playPlayerShootSound() {
            if (soundEnabled) {
                playerSynth.triggerAttackRelease("C4", "8n");
            }
        }

        function playEnemyShootSound() {
            if (soundEnabled) {
                enemySynth.triggerAttackRelease("A3", "8n");
            }
        }

        function toggleSound() {
            soundEnabled = soundToggle.checked;
            Tone.Master.mute = !soundEnabled; // Mute Tone.js master output if sound is disabled
            console.log("Sound Enabled:", soundEnabled);
        }

        function toggleStars() {
            starsEnabled = starsToggle.checked;
            console.log("Stars Enabled:", starsEnabled);
        }

        function initializeStars() {
            stars.length = 0;
            for (let i = 0; i < numStars; i++) {
                stars.push({
                    x: Math.random() * gameWidth,
                    y: Math.random() * gameHeight,
                    radius: Math.random() * 2,
                    alpha: Math.random() * 0.7 + 0.3,
                    speed: Math.random() * 0.5 + 0.5
                });
            }
        }

        function drawStars() {
            if (!starsEnabled) return; // Only draw stars if enabled
            ctx.fillStyle = '#ffffff';
            stars.forEach(star => {
                ctx.globalAlpha = star.alpha;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        }

        function updateStars() {
            if (!starsEnabled) return; // Only update stars if enabled
            stars.forEach(star => {
                star.y += star.speed;
                if (star.y > gameHeight) {
                    star.y = 0;
                    star.x = Math.random() * gameWidth;
                }
            });
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gameWidth = canvas.width;
            gameHeight = canvas.height;
            console.log(`resizeCanvas: Canvas resized to Width: ${gameWidth}, Height: ${gameHeight}`);


            player.x = gameWidth / 2 - player.width / 2;
            player.y = gameHeight - player.height - 50;
            player.initialY = player.y;

            messageDisplay.style.fontSize = `${Math.max(16, window.innerWidth / 50)}px`;
            shopDisplay.style.fontSize = `${Math.max(16, window.innerWidth / 60)}px`;
            settingsDisplay.style.fontSize = `${Math.max(16, window.innerWidth / 60)}px`;
            howToPlayDisplay.style.fontSize = `${Math.max(16, window.innerWidth / 60)}px`; // Adjust for new menu

            initializeStars();
        }

        // Removed drawPlayerHealthBar() as health is now an HTML element

        function drawPlayer() {
            player.draw();
            // No longer calling drawPlayerHealthBar() here
        }

        function drawBullet(bullet) {
            bulletProps.draw(bullet);
        }

        function drawGenericEnemy(enemy) {
            const type = enemy.type;
            const color = type.colors[0];
            ctx.fillStyle = color;

            ctx.beginPath();
            ctx.moveTo(enemy.x + type.width / 2, enemy.y);
            ctx.lineTo(enemy.x, enemy.y + type.height * 0.3);
            ctx.lineTo(enemy.x, enemy.y + type.height * 0.7);
            ctx.lineTo(enemy.x + type.width / 2, enemy.y + type.height);
            ctx.lineTo(enemy.x + type.width, enemy.y + type.height * 0.7);
            ctx.lineTo(enemy.x + type.width, enemy.y + type.height * 0.3);
            ctx.closePath();
            ctx.fill();

            ctx.strokeStyle = 'rgba(0,0,0,0.3)';
            ctx.lineWidth = 1;
            ctx.stroke();

            const eyeCenterX = enemy.x + type.width / 2;
            const eyeCenterY = enemy.y + type.height / 2;
            const eyeRadius = 8 * (type.width / 40);

            const glowGradient = ctx.createRadialGradient(eyeCenterX, eyeCenterY, 0, eyeCenterX, eyeCenterY, eyeRadius + 5);
            glowGradient.addColorStop(0, 'rgba(255, 255, 0, 0.8)');
            glowGradient.addColorStop(1, 'rgba(255, 255, 0, 0)');
            ctx.fillStyle = glowGradient;
            ctx.beginPath();
            ctx.arc(eyeCenterX, eyeCenterY, eyeRadius + 5, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#f7fafc';
            ctx.beginPath();
            ctx.arc(eyeCenterX, eyeCenterY, eyeRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#2d3748';
            ctx.beginPath();
            ctx.arc(eyeCenterX, eyeCenterY, eyeRadius * 0.4, 0, Math.PI * 2);
            ctx.fill();

            if (type.health > 10) {
                const healthBarWidth = type.width * 0.8;
                const healthBarHeight = 5;
                const healthBarX = enemy.x + (type.width - healthBarWidth) / 2;
                const healthBarY = enemy.y - 10;

                ctx.fillStyle = '#c53030';
                ctx.fillRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);

                const currentHealthWidth = (enemy.health / type.health) * healthBarWidth;
                ctx.fillStyle = '#48bb78';
                ctx.fillRect(healthBarX, healthBarY, currentHealthWidth, healthBarHeight);

                ctx.strokeStyle = '#e2e8f0';
                ctx.lineWidth = 1;
                ctx.strokeRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);
            }
        }

        function shootEnemyBullet(enemy) {
            const currentTime = Date.now();
            if (currentTime - enemy.lastShotTime > enemy.type.shootCooldown) {
                const startX = enemy.x + enemy.type.width / 2;
                const startY = enemy.y + enemy.type.height;

                const playerCenterX = player.x + player.width / 2;
                const playerCenterY = player.y + player.height / 2;

                const angle = Math.atan2(playerCenterY - startY, playerCenterX - startX);

                const bulletDx = enemy.type.bulletSpeed * Math.cos(angle);
                const bulletDy = enemy.type.bulletSpeed * Math.sin(angle);

                enemyBullets.push({
                    x: startX,
                    y: startY,
                    dx: bulletDx,
                    dy: bulletDy,
                    angle: angle
                });
                enemy.lastShotTime = currentTime;
                playEnemyShootSound();
            }
        }

        function shootBossBullet(boss) {
            const currentTime = Date.now();
            if (currentTime - boss.lastShotTime > boss.shootCooldown) {
                const startX = boss.x + boss.width / 2;
                const startY = boss.y + boss.height;

                const playerCenterX = player.x + player.width / 2;
                const playerCenterY = player.y + player.height / 2;

                const angle = Math.atan2(playerCenterY - startY, playerCenterX - startX);

                const bulletDx = boss.bulletSpeed * Math.cos(angle);
                const bulletDy = boss.bulletSpeed * Math.sin(angle);

                enemyBullets.push({
                    x: startX,
                    y: startY,
                    dx: bulletDx,
                    dy: bulletDy,
                    angle: angle
                });
                boss.lastShotTime = currentTime;
                playEnemyShootSound();
            }
        }

        function updatePlayer() {
            player.x += player.dx;
            player.y += player.dy;

            if (player.x < 0) player.x = 0;
            if (player.x + player.width > gameWidth) player.x = gameWidth - player.width;

            if (player.y < 0) player.y = 0;
            if (player.y + player.height > gameHeight) player.y = gameHeight - player.height;
        }

        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets [i];
                bullet.x += bullet.dx;
                bullet.y += bullet.dy;

                const currentDistanceSq = (bullet.x + bulletProps.width/2 - bullet.startX)**2 + (bullet.y + bulletProps.height/2 - bullet.startY)**2;

                if (currentDistanceSq >= bullet.totalTargetDistanceSq ||
                    bullet.y + bulletProps.height < 0 || bullet.y > gameHeight ||
                    bullet.x + bulletProps.width < 0 || bullet.x > gameWidth) {
                    bullets.splice(i, 1);
                }
            }
        }

        function updateEnemyBullets() {
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const bullet = enemyBullets[i];
                bullet.x += bullet.dx;
                bullet.y += bullet.dy;

                if (bullet.y > gameHeight || bullet.x < 0 || bullet.x > gameWidth) {
                    enemyBullets.splice(i, 1);
                }
            }
        }

        const enemySpawnWeights = {
            'small': 5,
            'medium': 2,
            'large': 1
        };

        function spawnEnemy() {
            const currentTime = Date.now();
            if (bossActive) {
                const selectedEnemyType = enemyTypes[0];
                const x = Math.random() * (gameWidth - selectedEnemyType.width);
                const y = -selectedEnemyType.height;
                enemies.push({
                    x,
                    y,
                    type: selectedEnemyType,
                    health: selectedEnemyType.health,
                    lastShotTime: currentTime
                });
                enemyProps.lastSpawnTime = currentTime;
                return;
            }

            if (currentTime - enemyProps.lastSpawnTime > enemyProps.spawnInterval) {
                let currentWeights = {};
                if (wave <= 1) {
                    currentWeights = { 'small': enemySpawnWeights.small };
                } else if (wave <= 3) {
                    currentWeights = { 'small': enemySpawnWeights.small, 'medium': enemySpawnWeights.medium };
                } else {
                    currentWeights = enemySpawnWeights;
                }

                let weightedEnemyTypes = [];
                for (const typeName in currentWeights) {
                    const weight = currentWeights[typeName];
                    const enemyType = enemyTypes.find(et => et.name === typeName);
                    if (enemyType) {
                        for (let i = 0; i < weight; i++) {
                            weightedEnemyTypes.push(enemyType);
                        }
                    }
                }

                const selectedEnemyType = weightedEnemyTypes[Math.floor(Math.random() * weightedEnemyTypes.length)];

                const x = Math.random() * (gameWidth - selectedEnemyType.width);
                const y = -selectedEnemyType.height;

                enemies.push({
                    x,
                    y,
                    type: selectedEnemyType,
                    health: selectedEnemyType.health,
                    lastShotTime: currentTime
                });
                enemyProps.lastSpawnTime = currentTime;
            }
        }

        function updateEnemies() {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies [i];
                enemy.y += enemy.type.baseSpeed + (bossFightsCompleted * speedIncreasePerBoss);

                if (enemy.type.canShoot) {
                    shootEnemyBullet(enemy);
                }

                if (enemy.y + enemy.type.height > gameHeight) {
                    enemies.splice(i, 1);
                }
            }
        }

        function updateBoss() {
            if (!bossActive) return;

            boss.x += boss.dx;

            if (boss.x < 0 || boss.x + boss.width > gameWidth) {
                boss.dx *= -1;
            }

            if (boss.y < gameHeight * 0.2) {
                boss.y += boss.speed * 0.5;
            }

            shootBossBullet(boss);
        }

        function checkCollisions() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const bullet = bullets [i];
                    const enemy = enemies [j];
                    if (bullet && enemy &&
                        bullet.x < enemy.x + enemy.type.width &&
                        bullet.x + bulletProps.width > enemy.x &&
                        bullet.y < enemy.y + enemy.type.height &&
                        bullet.y + bulletProps.height > enemy.y
                    ) {
                        bullets.splice(i, 1);
                        enemy.health -= 10;
                        if (enemy.health <= 0) {
                            enemies.splice(j, 1);
                            score += enemy.type.scoreValue;
                            enemiesDefeatedInWave++;
                            updateScoreDisplay();

                            if (!bossActive && enemiesDefeatedInWave >= enemiesRequiredForWave) {
                                wave++;
                                enemiesDefeatedInWave = 0;
                                enemyProps.spawnInterval = Math.max(50, baseSpawnInterval - ((wave - 1) % wavesPerBoss) * spawnIntervalDecreasePerWave);
                                console.log(`Wave ${wave} - New Spawn Interval: ${enemyProps.spawnInterval}`);
                                updateScoreDisplay();
                                showOverlayMessage(`Wave ${wave} Incoming!`);

                                if ((wave - 1) % wavesPerBoss === 0 && wave > 1) {
                                    enemies.length = 0;
                                    startBossFight();
                                }
                            }
                        }
                        break;
                    }
                }
            }

            if (bossActive) {
                for (let i = bullets.length - 1; i >= 0; i--) {
                    const bullet = bullets[i];
                    if (
                        bullet.x < boss.x + boss.width &&
                        bullet.x + bulletProps.width > boss.x &&
                        bullet.y < boss.y + boss.height &&
                        bullet.y + bulletProps.height > boss.y
                    ) {
                        bullets.splice(i, 1);
                        boss.health -= 1;
                        updateBossHealthDisplay();
                        if (boss.health <= 0) {
                            defeatBoss();
                        }
                        break;
                    }
                }
            }

            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies [i];
                if (
                    player.x < enemy.x + enemy.type.width &&
                    player.x + player.width > enemy.x &&
                    player.y < enemy.y + player.height &&
                    player.y + player.height > enemy.y
                ) {
                    enemies.splice(i, 1);
                    takeDamage(5, 'enemy collision');
                    break;
                }
            }

            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const eBullet = enemyBullets[i];
                if (
                    eBullet.x < player.x + player.width &&
                    eBullet.x + enemyBulletProps.width > player.x &&
                    eBullet.y < player.y + player.height &&
                    eBullet.y + enemyBulletProps.height > player.y
                ) {
                    enemyBullets.splice(i, 1);
                    takeDamage(enemyBulletProps.damage, 'enemy bullet');
                    break;
                }
            }

            if (bossActive) {
                if (
                    player.x < boss.x + boss.width &&
                    player.x + player.width > boss.x &&
                    player.y < boss.y + boss.height &&
                    player.y + player.height > boss.y
                ) {
                    takeDamage(50, 'boss collision');
                    return;
                }
            }
        }

        function shoot() {
            const currentTime = Date.now();
            if (currentTime - bulletProps.lastShotTime > bulletProps.cooldown) {
                const startX = player.x + player.width / 2;
                const startY = player.y + player.height / 2;

                const targetX = aimIndicator.x;
                const targetY = aimIndicator.y;

                const deltaX = targetX - startX;
                const deltaY = targetY - startY;
                const angle = Math.atan2(deltaY, deltaX);

                const bulletDx = bulletProps.speed * Math.cos(angle);
                const bulletDy = bulletProps.speed * Math.sin(angle);

                const totalTargetDistanceSq = (targetX - startX)**2 + (targetY - startY)**2;

                bullets.push({
                    x: startX - bulletProps.width / 2,
                    y: startY - bulletProps.height / 2,
                    dx: bulletDx,
                    dy: bulletDy,
                    startX: startX,
                    startY: startY,
                    totalTargetDistanceSq: totalTargetDistanceSq,
                    angle: angle
                });
                bulletProps.lastShotTime = currentTime;
                playPlayerShootSound();
            }
        }

        function updateScoreDisplay() {
            scoreBoard.textContent = `Score: ${score}`;
            waveBoard.textContent = `Wave: ${wave}`;
        }

        function updateHealthDisplay() {
            const healthPercentage = (playerHealth / playerMaxHealth) * 100;
            currentHealthBar.style.width = `${healthPercentage}%`;
            // You can also change the color based on health percentage if desired
            if (healthPercentage > 50) {
                currentHealthBar.style.backgroundColor = '#48bb78'; // Green
            } else if (healthPercentage > 20) {
                currentHealthBar.style.backgroundColor = '#f6ad55'; // Orange
            } else {
                currentHealthBar.style.backgroundColor = '#e53e3e'; // Red
            }
        }

        function updateBossHealthDisplay() {
            // Health bar is drawn directly in boss.draw()
        }

        function takeDamage(amount, reason = 'unknown cause') {
            console.log(`Player took ${amount} damage due to: ${reason}`);
            playerHealth -= amount;
            if (playerHealth < 0) {
                playerHealth = 0;
            }
            updateHealthDisplay();

            flashEffect.active = true;
            flashEffect.startTime = Date.now();

            if (playerHealth <= 0) {
                gameOver();
            }
        }

        function gameOver() {
            gameRunning = false;
            bossActive = false;
            paused = false;
            shopOpen = false;
            settingsOpen = false;
            howToPlayOpen = false; // Ensure howToPlay is closed
            cancelAnimationFrame(animationFrameId);

            messageText.textContent = `Game Over! Final Score: ${score}`;
            messageDisplay.style.display = 'flex';
            startButton.classList.add('hidden');
            restartButton.classList.remove('hidden');
            howToPlayButtonTitle.classList.remove('hidden'); // Show how to play button
            settingsButtonTitle.classList.remove('hidden'); // Show settings button on game over screen

            messageDisplay.classList.remove('overlay-message');

            uiContainer.classList.add('hidden');
            scoreBoard.classList.add('hidden');
            waveBoard.classList.add('hidden');
            healthBarDisplay.classList.add('hidden'); // Hide the new health bar
            shopButton.classList.add('hidden');
            pauseButton.classList.add('hidden');
            settingsButtonInGame.classList.add('hidden');
            shopDisplay.style.display = 'none'; // Ensure shop is hidden
            settingsDisplay.style.display = 'none'; // Ensure settings are hidden
            howToPlayDisplay.style.display = 'none'; // Ensure howToPlay is hidden

            startTitleAnimation();
        }

        function showOverlayMessage(message) {
            messageText.textContent = message;
            messageDisplay.style.display = 'block';
            messageDisplay.classList.add('overlay-message');
            startButton.classList.add('hidden');
            restartButton.classList.add('hidden');
            howToPlayButtonTitle.classList.add('hidden'); // Hide how to play button
            settingsButtonTitle.classList.add('hidden'); // Hide settings button for simple messages

            setTimeout(() => {
                messageDisplay.style.display = 'none';
                messageDisplay.classList.remove('overlay-message');
            }, 2000);
        }


        function startBossFight() {
            bossActive = true;
            enemies.length = 0;
            boss.maxHealth = 100 + (Math.floor(wave / wavesPerBoss) - 1) * 100;
            boss.health = boss.maxHealth;
            boss.width = gameWidth * 0.6;
            boss.height = 80;
            boss.x = gameWidth / 2 - boss.width / 2;
            boss.y = -boss.height;
            boss.speed = 1 + (Math.floor(wave / wavesPerBoss) - 1) * 0.5;
            boss.dx = boss.speed;
            boss.lastShotTime = Date.now();
            updateBossHealthDisplay();
            showOverlayMessage("BOSS BATTLE INCOMING!");
        }

        function defeatBoss() {
            bossActive = false;
            score += 500;
            updateScoreDisplay();
            showOverlayMessage(`Boss Defeated! Wave ${wave + 1} Incoming!`);

            bossFightsCompleted++;
            enemyProps.spawnInterval = baseSpawnInterval;
            console.log(`Boss Defeated! New Enemy Speed Base: ${baseEnemySpeed + (bossFightsCompleted * speedIncreasePerBoss)}, Spawn Interval Reset: ${enemyProps.spawnInterval}`);

            wave++;
            enemiesDefeatedInWave = 0;
            enemiesRequiredForWave = 15;
            enemies.length = 0;
            enemyBullets.length = 0;
        }

        function startGame() {
            console.log("startGame called.");
            if (titleAnimationId) {
                cancelAnimationFrame(titleAnimationId);
                titleAnimationId = null;
            }

            score = 0;
            playerHealth = playerMaxHealth; // Initialize playerHealth to the new playerMaxHealth
            wave = 1;
            enemiesRequiredForWave = 15;
            enemiesDefeatedInWave = 0;
            gameRunning = true;
            shopOpen = false;
            bossActive = false;
            paused = false;
            settingsOpen = false; // Ensure settings are closed when game starts
            howToPlayOpen = false; // Ensure howToPlay is closed when game starts
            bullets.length = 0;
            enemies.length = 0;
            enemyBullets.length = 0;

            bossFightsCompleted = 0;
            enemyProps.spawnInterval = baseSpawnInterval;
            enemyProps.lastSpawnTime = Date.now();
            console.log(`Game Started! Initial Enemy Speed Base: ${baseEnemySpeed + (bossFightsCompleted * speedIncreasePerBoss)}, Spawn Interval: ${enemyProps.spawnInterval}`);

            bulletProps.lastShotTime = 0;
            player.dx = 0;
            player.dy = 0;
            player.currentAngle = -Math.PI / 2;
            player.targetAngle = -Math.PI / 2;
            player.y = player.initialY;
            player.titleAnimationOffset = 0;

            MAX_AIM_DISTANCE = 250;
            for (const key in shopItems) {
                shopItems [key].currentLevel = 0;
            }
            player.speed = 7;
            bulletProps.speed = 10;

            updateScoreDisplay();
            updateHealthDisplay(); // Call to update the new HTML health bar
            resizeCanvas(); // Ensure canvas is correctly sized before drawing

            messageDisplay.style.display = 'none';
            messageDisplay.classList.remove('overlay-message');

            startButton.classList.add('hidden');
            restartButton.classList.add('hidden');
            howToPlayButtonTitle.classList.add('hidden'); // Hide how to play button
            settingsButtonTitle.classList.add('hidden'); // Hide title settings button
            settingsDisplay.style.display = 'none'; // Explicitly hide settings display on game start
            howToPlayDisplay.style.display = 'none'; // Explicitly hide how to play display on game start

            // Show game UI elements
            uiContainer.classList.remove('hidden');
            scoreBoard.classList.remove('hidden');
            waveBoard.classList.remove('hidden');
            healthBarDisplay.classList.remove('hidden'); // Show the new health bar
            shopButton.classList.remove('hidden');
            pauseButton.classList.remove('hidden');
            settingsButtonInGame.classList.remove('hidden'); // Show in-game settings button

            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            animationFrameId = requestAnimationFrame(gameLoopWithInput);
            console.log("startGame finished. gameRunning:", gameRunning);
        };

        function pauseGame() {
            if (!gameRunning || paused || shopOpen || settingsOpen || howToPlayOpen) return; // Use settingsOpen and howToPlayOpen flag
            paused = true;
            cancelAnimationFrame(animationFrameId);
            showOverlayMessage("Game Paused");
            console.log("Game Paused. gameRunning:", gameRunning, "paused:", paused);

            // Hide game UI elements during pause
            uiContainer.classList.add('hidden');
            scoreBoard.classList.add('hidden');
            waveBoard.classList.add('hidden');
            healthBarDisplay.classList.add('hidden'); // Hide the new health bar
            shopButton.classList.add('hidden');
            pauseButton.classList.add('hidden');
            settingsButtonInGame.classList.add('hidden');
        }

        function resumeGame() {
            if (!gameRunning || !paused || shopOpen || settingsOpen || howToPlayOpen) return; // Use settingsOpen and howToPlayOpen flag
            paused = false;
            messageDisplay.style.display = 'none';
            messageDisplay.classList.remove('overlay-message');
            console.log("Game Resumed. gameRunning:", gameRunning, "paused:", paused);

            // Show game UI elements
            uiContainer.classList.remove('hidden');
            scoreBoard.classList.remove('hidden');
            waveBoard.classList.remove('hidden');
            healthBarDisplay.classList.remove('hidden'); // Show the new health bar
            shopButton.classList.remove('hidden');
            pauseButton.classList.remove('hidden');
            settingsButtonInGame.classList.remove('hidden'); // Show in-game settings button
            animationFrameId = requestAnimationFrame(gameLoopWithInput);
        }

        function togglePause() {
            if (gameRunning && !shopOpen && !settingsOpen && !howToPlayOpen) { // Use settingsOpen and howToPlayOpen flag
                if (paused) {
                    resumeGame();
                } else {
                    pauseGame();
                }
            }
        }

        function openShop() {
            wasGameRunningBeforeShop = gameRunning;
            console.log("openShop called. gameRunning before:", gameRunning, "wasGameRunningBeforeShop:", wasGameRunningBeforeShop);

            if (gameRunning) {
                gameRunning = false;
                cancelAnimationFrame(animationFrameId);
            }
            if (titleAnimationId) {
                cancelAnimationFrame(titleAnimationId);
                titleAnimationId = null;
            }
            paused = false; // Ensure not paused when shop is open
            settingsOpen = false; // Ensure settings are closed
            howToPlayOpen = false; // Ensure howToPlay is closed

            shopOpen = true;
            messageDisplay.style.display = 'none';
            messageDisplay.classList.remove('overlay-message');
            settingsDisplay.style.display = 'none'; // Ensure settings are hidden
            howToPlayDisplay.style.display = 'none'; // Ensure howToPlay is hidden
            shopDisplay.style.display = 'block';
            renderShopItems();

            // Hide game UI elements when shop is open
            uiContainer.classList.add('hidden');
            scoreBoard.classList.add('hidden');
            waveBoard.classList.add('hidden');
            healthBarDisplay.classList.add('hidden'); // Hide the new health bar
            shopButton.classList.add('hidden');
            pauseButton.classList.add('hidden');
            settingsButtonInGame.classList.add('hidden');
            console.log("openShop finished. gameRunning:", gameRunning, "shopOpen:", shopOpen);
        }

        function closeShop() {
            shopOpen = false;
            shopDisplay.style.display = 'none';
            console.log("closeShop called. wasGameRunningBeforeShop:", wasGameRunningBeforeShop);

            if (wasGameRunningBeforeShop) {
                gameRunning = true;
                // Show game UI elements
                uiContainer.classList.remove('hidden');
                scoreBoard.classList.remove('hidden');
                waveBoard.classList.remove('hidden');
                healthBarDisplay.classList.remove('hidden'); // Show the new health bar
                shopButton.classList.remove('hidden');
                pauseButton.classList.remove('hidden');
                settingsButtonInGame.classList.remove('hidden'); // Show in-game settings button
                animationFrameId = requestAnimationFrame(gameLoopWithInput);
                console.log("closeShop finished. Resuming game. gameRunning:", gameRunning);
            } else {
                startTitleAnimation();
                messageText.textContent = "That Shooting Game";
                messageDisplay.style.display = 'flex'; // Display as panel
                startButton.classList.remove('hidden');
                restartButton.classList.add('hidden');
                howToPlayButtonTitle.classList.remove('hidden'); // Show how to play button
                settingsButtonTitle.classList.remove('hidden'); // Show title settings button
                messageDisplay.classList.remove('overlay-message');

                // Set flag to prevent immediate clicks
                isTransitioningFromMenu = true;
                setTimeout(() => {
                    isTransitioningFromMenu = false;
                    console.log("isTransitioningFromMenu reset to false (from closeShop).");
                }, 200); // Short delay

                console.log("closeShop finished. Returning to title. gameRunning:", gameRunning);
            }
        }

        function openSettings() {
            console.log("openSettings called. gameRunning before:", gameRunning);
            // Store the current gameRunning state before pausing for settings
            wasGameRunningBeforeSettings = gameRunning;

            if (gameRunning) {
                gameRunning = false; // Temporarily set to false to pause the game loop
                cancelAnimationFrame(animationFrameId); // Pause game loop
            }
            // Stop title animation if it's running and settings is opened from title
            if (titleAnimationId) {
                cancelAnimationFrame(titleAnimationId);
                titleAnimationId = null;
            }
            paused = false; // Ensure not paused when settings are open
            shopOpen = false; // Ensure shop is closed
            howToPlayOpen = false; // Ensure howToPlay is closed

            settingsOpen = true; // Set settingsOpen flag to true
            messageDisplay.style.display = 'none'; // Hide game over/title message
            shopDisplay.style.display = 'none'; // Ensure shop is hidden
            howToPlayDisplay.style.display = 'none'; // Ensure howToPlay is hidden
            settingsDisplay.style.display = 'block'; // Show settings display

            // Update toggle state to match current soundEnabled
            soundToggle.checked = soundEnabled;
            starsToggle.checked = starsEnabled; // Set stars toggle state

            // Hide game UI elements when settings are open
            uiContainer.classList.add('hidden');
            scoreBoard.classList.add('hidden');
            waveBoard.classList.add('hidden');
            healthBarDisplay.classList.add('hidden'); // Hide the new health bar
            shopButton.classList.add('hidden');
            pauseButton.classList.add('hidden');
            settingsButtonInGame.classList.add('hidden');
            startButton.classList.add('hidden'); // Hide start button
            restartButton.classList.add('hidden'); // Hide restart button
            howToPlayButtonTitle.classList.add('hidden'); // Hide how to play button
            settingsButtonTitle.classList.add('hidden'); // Hide title settings button
            console.log("openSettings finished. wasGameRunningBeforeSettings:", wasGameRunningBeforeSettings, "gameRunning:", gameRunning);
        }

        function closeSettings() {
            settingsOpen = false; // Set settingsOpen flag to false
            settingsDisplay.style.display = 'none';
            console.log("closeSettings called. wasGameRunningBeforeSettings:", wasGameRunningBeforeSettings);

            // Use the stored state to decide whether to resume game or title animation
            if (wasGameRunningBeforeSettings) {
                gameRunning = true; // Restore gameRunning state
                // Show game UI elements
                uiContainer.classList.remove('hidden');
                scoreBoard.classList.remove('hidden');
                waveBoard.classList.remove('hidden');
                healthBarDisplay.classList.remove('hidden'); // Show the new health bar
                shopButton.classList.remove('hidden');
                pauseButton.classList.remove('hidden');
                settingsButtonInGame.classList.remove('hidden'); // Show in-game settings button
                animationFrameId = requestAnimationFrame(gameLoopWithInput); // Resume the game loop
                console.log("closeSettings finished. Resuming game. gameRunning:", gameRunning);
            } else {
                // If game was not running (came from title screen), start title animation
                startTitleAnimation();
                // Show only start button and game title
                messageText.textContent = "That Shooting Game";
                messageDisplay.style.display = 'flex'; // Display as panel
                startButton.classList.remove('hidden');
                restartButton.classList.add('hidden');
                howToPlayButtonTitle.classList.remove('hidden'); // Show how to play button
                settingsButtonTitle.classList.remove('hidden'); // Show title settings button

                // Set flag to prevent immediate clicks
                isTransitioningFromMenu = true;
                setTimeout(() => {
                    isTransitioningFromMenu = false;
                    console.log("isTransitioningFromMenu reset to false (from closeSettings).");
                }, 200); // Short delay to prevent ghost clicks

                console.log("closeSettings finished. Returning to title screen. gameRunning:", gameRunning);
            }
        }

        function openHowToPlay() {
            console.log("openHowToPlay called. gameRunning before:", gameRunning);
            wasGameRunningBeforeHowToPlay = gameRunning;

            if (gameRunning) {
                gameRunning = false;
                cancelAnimationFrame(animationFrameId);
            }
            if (titleAnimationId) {
                cancelAnimationFrame(titleAnimationId);
                titleAnimationId = null;
            }
            paused = false;
            shopOpen = false;
            settingsOpen = false;

            howToPlayOpen = true;
            messageDisplay.style.display = 'none';
            shopDisplay.style.display = 'none';
            settingsDisplay.style.display = 'none';
            howToPlayDisplay.style.display = 'block';

            uiContainer.classList.add('hidden');
            scoreBoard.classList.add('hidden');
            waveBoard.classList.add('hidden');
            healthBarDisplay.classList.add('hidden');
            shopButton.classList.add('hidden');
            pauseButton.classList.add('hidden');
            settingsButtonInGame.classList.add('hidden');
            startButton.classList.add('hidden');
            restartButton.classList.add('hidden');
            howToPlayButtonTitle.classList.add('hidden');
            settingsButtonTitle.classList.add('hidden');
            console.log("openHowToPlay finished. wasGameRunningBeforeHowToPlay:", wasGameRunningBeforeHowToPlay, "gameRunning:", gameRunning);
        }

        function closeHowToPlay() {
            howToPlayOpen = false;
            howToPlayDisplay.style.display = 'none';
            console.log("closeHowToPlay called. wasGameRunningBeforeHowToPlay:", wasGameRunningBeforeHowToPlay);

            if (wasGameRunningBeforeHowToPlay) {
                gameRunning = true;
                uiContainer.classList.remove('hidden');
                scoreBoard.classList.remove('hidden');
                waveBoard.classList.remove('hidden');
                healthBarDisplay.classList.remove('hidden');
                shopButton.classList.remove('hidden');
                pauseButton.classList.remove('hidden');
                settingsButtonInGame.classList.remove('hidden');
                animationFrameId = requestAnimationFrame(gameLoopWithInput);
                console.log("closeHowToPlay finished. Resuming game. gameRunning:", gameRunning);
            } else {
                startTitleAnimation();
                messageText.textContent = "That Shooting Game";
                messageDisplay.style.display = 'flex';
                startButton.classList.remove('hidden');
                restartButton.classList.add('hidden');
                howToPlayButtonTitle.classList.remove('hidden');
                settingsButtonTitle.classList.remove('hidden');

                isTransitioningFromMenu = true;
                setTimeout(() => {
                    isTransitioningFromMenu = false;
                    console.log("isTransitioningFromMenu reset to false (from closeHowToPlay).");
                }, 200);

                console.log("closeHowToPlay finished. Returning to title screen. gameRunning:", gameRunning);
            }
        }

        function renderShopItems() {
            shopItemsContainer.innerHTML = '';
            shopScoreDisplay.textContent = score;

            for (const key in shopItems) {
                const item = shopItems [key];
                const itemCost = item.getCost();
                const itemDisplayName = item.getDisplayName();

                const itemDiv = document.createElement('div');
                itemDiv.className = 'shop-item-button';

                const nameSpan = document.createElement('span');
                nameSpan.textContent = itemDisplayName;
                itemDiv.appendChild(nameSpan);

                const costSpan = document.createElement('span');
                costSpan.textContent = `${itemCost} pts`;
                costSpan.classList.add('font-bold', 'text-yellow-300');
                itemDiv.appendChild(costSpan);

                const buyButton = document.createElement('button');
                buyButton.textContent = 'Buy';
                buyButton.className = 'ml-4 px-4 py-2 bg-green-500 text-white rounded-md hover:bg-green-600 transition-colors';
                buyButton.onclick = () => buyItem(item.id);

                if (item.id === 'healthPack' && playerHealth >= playerMaxHealth) {
                    buyButton.disabled = true;
                    buyButton.classList.remove('hover:bg-green-600');
                    buyButton.classList.add('bg-gray-500', 'cursor-not-allowed');
                } else if (score < itemCost || (item.maxLevel && item.currentLevel >= item.maxLevel)) {
                    buyButton.disabled = true;
                    buyButton.classList.remove('hover:bg-green-600');
                    buyButton.classList.add('bg-gray-500', 'cursor-not-allowed');
                }

                itemDiv.appendChild(buyButton);
                shopItemsContainer.appendChild(itemDiv);
            }
        }

        function buyItem(itemId) {
            const item = shopItems [itemId];
            const itemCost = item.getCost();

            if (score >= itemCost) {
                score -= itemCost;
                updateScoreDisplay();
                item.effect();

                if (item.currentLevel !== undefined) {
                    item.currentLevel++;
                }
                renderShopItems();
            } else {
                console.log("Not enough points!");
            }
        }

        const keyState = {};

        window.addEventListener('keydown', (e) => {
            keyState [e.key.toLowerCase()] = true;
            if (e.key === ' ' || e.key === 'spacebar') {
                e.preventDefault();
                if (gameRunning && !paused && !shopOpen && !settingsOpen && !howToPlayOpen) shoot(); // Use all menu flags
            } else if (e.key === 'Escape') {
                e.preventDefault();
                // If any menu is open, close it first
                if (shopOpen) {
                    closeShop();
                } else if (settingsOpen) {
                    closeSettings();
                } else if (howToPlayOpen) {
                    closeHowToPlay();
                }
                else {
                    togglePause();
                }
            }
        });

        window.addEventListener('keyup', (e) => {
            keyState [e.key.toLowerCase()] = false;
        });

        window.addEventListener('click', (e) => {
            if (gameRunning && !paused && !shopOpen && !settingsOpen && !howToPlayOpen) { // Use all menu flags
                shoot();
            }
        });

        let touchLeftActive = false;
        let touchRightActive = false;
        let touchUpActive = false;
        let touchDownActive = false;

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
            mouse.isOverCanvas = true;
        });

        canvas.addEventListener('mouseleave', () => {
            mouse.isOverCanvas = false;
        });

        function handleMovementInput() {
            player.dx = 0;
            player.dy = 0;

            if (keyState['arrowleft'] || keyState['a'] || touchLeftActive) {
                player.dx = -player.speed;
            }
            if (keyState['arrowright'] || keyState['d'] || touchRightActive) {
                player.dx = player.speed;
            }
            if (keyState['arrowup'] || keyState['w'] || touchUpActive) {
                player.dy = -player.speed;
            }
            if (keyState['arrowdown'] || keyState['s'] || touchDownActive) {
                player.dy = player.speed;
            }
        }

        function updatePlayerRotation() {
            const playerCenterX = player.x + player.width / 2;
            const playerCenterY = player.y + player.height / 2;

            if (mouse.isOverCanvas) {
                player.targetAngle = Math.atan2(mouse.y - playerCenterY, mouse.x - playerCenterX);
            } else {
                player.targetAngle = -Math.PI / 2;
            }

            // Directly set currentAngle to targetAngle for instant rotation
            player.currentAngle = player.targetAngle;

            player.currentAngle = (player.currentAngle + Math.PI * 2) % (2 * Math.PI);
            if (player.currentAngle > Math.PI) player.currentAngle -= 2 * Math.PI;
        }

        function updateAimIndicator() {
            const playerCenterX = player.x + player.width / 2;
            const playerCenterY = player.y + player.height / 2;

            let mouseTargetX = mouse.x;
            let mouseTargetY = mouse.y;

            // If mouse is not over canvas, aim straight up
            if (!mouse.isOverCanvas) {
                mouseTargetX = playerCenterX;
                mouseTargetY = playerCenterY - MAX_AIM_DISTANCE; // Aim straight up
            }

            // Calculate raw angle from player to mouse
            let rawAngleToMouse = Math.atan2(mouseTargetY - playerCenterY, mouseTargetX - playerCenterX);

            // Calculate difference between raw angle and player's current angle
            let angleDiffFromPlayer = rawAngleToMouse - player.currentAngle;

            // Normalize angleDiffFromPlayer to be within -PI to PI
            if (angleDiffFromPlayer > Math.PI) angleDiffFromPlayer -= 2 * Math.PI;
            if (angleDiffFromPlayer < -Math.PI) angleDiffFromPlayer += 2 * Math.PI;

            // Clamp this difference to MAX_AIM_ANGLE_RADIANS
            let clampedAngleDiff = Math.max(-MAX_AIM_ANGLE_RADIANS, Math.min(MAX_AIM_ANGLE_RADIANS, angleDiffFromPlayer));

            // Add the clamped difference to player.currentAngle to get the actual aim angle for the indicator
            let actualAimAngle = player.currentAngle + clampedAngleDiff;

            // Calculate the distance from the player to the mouse
            let distanceToMouse = Math.sqrt( (mouseTargetX - playerCenterX)**2 + (mouseTargetY - playerCenterY)**2 );

            // Clamp this distance to MAX_AIM_DISTANCE
            let finalDistance = Math.min(distanceToMouse, MAX_AIM_DISTANCE);

            // Use actualAimAngle and finalDistance to set aimIndicator.x and aimIndicator.y
            aimIndicator.x = playerCenterX + finalDistance * Math.cos(actualAimAngle);
            aimIndicator.y = playerCenterY + finalDistance * Math.sin(actualAimAngle);
        }

        function gameLoopWithInput() {
            if (!gameRunning || shopOpen || paused || settingsOpen || howToPlayOpen) { // Use all menu flags
                console.log("gameLoop: Not running due to state. gameRunning=", gameRunning, "shopOpen=", shopOpen, "paused=", paused, "settingsOpen=", settingsOpen, "howToPlayOpen=", howToPlayOpen);
                return;
            }

            console.log("gameLoop: Running. Canvas dimensions: gameWidth=", gameWidth, "gameHeight=", gameHeight);

            // Clear canvas background
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, gameWidth, gameHeight);
            console.log("gameLoop: Background cleared.");

            handleMovementInput();
            updatePlayerRotation();
            updateAimIndicator();

            updateStars();
            drawStars();
            console.log("Stars updated and drawn.");

            updatePlayer();
            drawPlayer();
            console.log("Player updated and drawn at:", player.x, player.y);
            aimIndicator.draw();

            if (bossActive) {
                updateBoss();
                boss.draw();
                console.log("Boss updated and drawn.");
            } else {
                spawnEnemy();
                updateEnemies();
                enemies.forEach(enemy => drawGenericEnemy(enemy));
                if (enemies.length > 0) {
                    console.log("Enemies updated and drawn. First enemy at:", enemies[0].x, enemies[0].y);
                }
            }

            updateBullets();
            bullets.forEach(drawBullet);
            if (bullets.length > 0) {
                console.log("Bullets updated and drawn. First bullet at:", bullets[0].x, bullets[0].y);
            }

            updateEnemyBullets();
            enemyBullets.forEach(bullet => enemyBulletProps.draw(bullet));
            if (enemyBullets.length > 0) {
                console.log("Enemy bullets updated and drawn. First enemy bullet at:", enemyBullets[0].x, enemyBullets[0].y);
            }

            checkCollisions();

            if (flashEffect.active) {
                ctx.fillStyle = flashEffect.color;
                ctx.fillRect(0, 0, gameWidth, gameHeight);
                if (Date.now() - flashEffect.startTime > flashEffect.duration) {
                    flashEffect.active = false;
                }
            }

            // Request next frame
            animationFrameId = requestAnimationFrame(gameLoopWithInput);
        }

        function updateTitleScreenPlayer() {
            player.titleAnimationOffset += player.titleAnimationDirection * player.titleAnimationSpeed;
            if (player.titleAnimationOffset > player.titleAnimationMaxOffset || player.titleAnimationOffset < -player.titleAnimationMaxOffset) {
                player.titleAnimationDirection *= -1;
            }
            player.y = player.initialY + player.titleAnimationOffset;
        }

        function titleScreenAnimationLoop() {
            if (gameRunning || shopOpen || settingsOpen || howToPlayOpen) { // Use all menu flags
                cancelAnimationFrame(titleAnimationId);
                titleAnimationId = null;
                return;
            }

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, gameWidth, gameHeight);

            updateStars();
            drawStars();

            updateTitleScreenPlayer();
            drawPlayer();

            titleAnimationId = requestAnimationFrame(titleScreenAnimationLoop);
        }

        function startTitleAnimation() {
            if (!titleAnimationId) {
                player.y = player.initialY;
                player.titleAnimationOffset = 0;
                player.titleAnimationDirection = 1;
                titleAnimationId = requestAnimationFrame(titleScreenAnimationLoop);
            }
        }

        touchLeftBtn.addEventListener('touchstart', (e) => { e.preventDefault(); touchLeftActive = true; });
        touchLeftBtn.addEventListener('touchend', (e) => { e.preventDefault(); touchLeftActive = false; });
        touchLeftBtn.addEventListener('touchcancel', (e) => { e.preventDefault(); touchLeftActive = false; });

        touchRightBtn.addEventListener('touchstart', (e) => { e.preventDefault(); touchRightActive = true; });
        touchRightBtn.addEventListener('touchend', (e) => { e.preventDefault(); touchRightActive = false; });
        touchRightBtn.addEventListener('touchcancel', (e) => { e.preventDefault(); touchRightActive = false; });

        touchShootBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameRunning && !paused && !shopOpen && !settingsOpen && !howToPlayOpen) { // Use all menu flags
                shoot();
            }
        });

        const touchUpBtn = document.createElement('button');
        touchUpBtn.id = 'touchUpBtn';
        touchUpBtn.textContent = 'â–²';
        touchUpBtn.classList.add('touch-control-vertical', 'px-4', 'py-2', 'bg-blue-500', 'text-white', 'rounded-full', 'font-semibold', 'hover:bg-blue-600', 'transition-colors');
        document.querySelector('.touch-controls').insertBefore(touchUpBtn, touchShootBtn);

        const touchDownBtn = document.createElement('button');
        touchDownBtn.id = 'touchDownBtn';
        touchDownBtn.textContent = 'â–¼';
        touchDownBtn.classList.add('touch-control-vertical', 'px-4', 'py-2', 'bg-blue-500', 'text-white', 'rounded-full', 'font-semibold', 'hover:bg-blue-600', 'transition-colors');
        document.querySelector('.touch-controls').insertBefore(touchDownBtn, touchShootBtn.nextSibling);

        touchUpBtn.addEventListener('touchstart', (e) => { e.preventDefault(); touchUpActive = true; });
        touchUpBtn.addEventListener('touchend', (e) => { e.preventDefault(); touchUpActive = false; });
        touchUpBtn.addEventListener('touchcancel', (e) => { e.preventDefault(); touchUpActive = false; });

        touchDownBtn.addEventListener('touchstart', (e) => { e.preventDefault(); touchDownActive = true; });
        touchDownBtn.addEventListener('touchend', (e) => { e.preventDefault(); touchDownActive = false; });
        touchDownBtn.addEventListener('touchcancel', (e) => { e.preventDefault(); touchDownActive = false; });

        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', startGame);
        shopButton.addEventListener('click', openShop);
        closeShopBtn.addEventListener('click', closeShop);
        pauseButton.addEventListener('click', togglePause);
        settingsButtonTitle.addEventListener('click', openSettings); // Event listener for title settings button
        settingsButtonInGame.addEventListener('click', openSettings); // Event listener for in-game settings button
        closeSettingsBtn.addEventListener('click', closeSettings); // Event listener for close settings button
        soundToggle.addEventListener('change', toggleSound); // Event listener for sound toggle
        starsToggle.addEventListener('change', toggleStars); // Event listener for stars toggle
        howToPlayButtonTitle.addEventListener('click', openHowToPlay); // Event listener for how to play button
        closeHowToPlayBtn.addEventListener('click', closeHowToPlay); // Event listener for close how to play button

        window.addEventListener('resize', () => {
            resizeCanvas();
            if (!gameRunning && !shopOpen && !settingsOpen && !howToPlayOpen) { // Use all menu flags
                startTitleAnimation();
            }
            if (shopOpen) {
                renderShopItems();
            }
        });

        window.onload = () => {
            console.log("Window loaded. Initializing game.");
            Tone.start().then(() => {
                console.log("Audio context started successfully!");
            }).catch(e => {
                console.error("Error starting audio context:", e);
            });

            resizeCanvas();
            updateScoreDisplay();
            updateHealthDisplay(); // Initial update for the new HTML health bar
            initializeStars();

            messageText.textContent = "That Shooting Game";
            messageDisplay.style.display = 'flex';
            startButton.classList.remove('hidden');
            restartButton.classList.add('hidden');
            howToPlayButtonTitle.classList.remove('hidden'); // Show how to play button on initial load
            settingsButtonTitle.classList.remove('hidden'); // Show settings button on initial load

            scoreBoard.classList.add('hidden');
            waveBoard.classList.add('hidden');
            healthBarDisplay.classList.add('hidden'); // Hide the new health bar initially
            shopButton.classList.add('hidden');
            pauseButton.classList.add('hidden');
            settingsButtonInGame.classList.add('hidden'); // Hide in-game settings button initially
            shopDisplay.style.display = 'none'; // Ensure hidden
            settingsDisplay.style.display = 'none'; // Ensure hidden
            howToPlayDisplay.style.display = 'none'; // Ensure hidden

            // Initialize toggle states
            soundToggle.checked = soundEnabled;
            Tone.Master.mute = !soundEnabled;
            starsToggle.checked = starsEnabled;

            startTitleAnimation();
            console.log("Window onload finished. gameRunning:", gameRunning);
        };

        // --- Console Commands for Playtesting ---
        /**
         * Advances the game to the next wave.
         * Can be called from the browser's developer console for playtesting.
         */
        window.advanceWave = function() {
            if (!gameRunning) {
                console.warn("Game is not running. Start the game before advancing waves.");
                return;
            }

            if (bossActive) {
                defeatBoss();
                console.log(`Boss defeated! Advancing to Wave ${wave}.`);
            } else {
                enemiesDefeatedInWave = enemiesRequiredForWave;
                if (!bossActive && enemiesDefeatedInWave >= enemiesRequiredForWave) {
                    wave++;
                    enemiesDefeatedInWave = 0;
                    enemyProps.spawnInterval = Math.max(50, baseSpawnInterval - ((wave - 1) % wavesPerBoss) * spawnIntervalDecreasePerWave);
                    console.log(`Wave ${wave} - New Spawn Interval: ${enemyProps.spawnInterval}`);
                    updateScoreDisplay();
                    showOverlayMessage(`Wave ${wave} Incoming!`);

                    if ((wave - 1) % wavesPerBoss === 0 && wave > 1) {
                        enemies.length = 0;
                        startBossFight();
                    }
                }
                console.log(`Advanced to Wave ${wave}.`);
            }
            enemies.length = 0;
            enemyBullets.length = 0;
        };

        /**
         * Gives the player a specified amount of score.
         * @param {number} amount - The amount of score to add.
         */
        window.addScore = function(amount) {
            if (typeof amount !== 'number' || amount <= 0) {
                console.warn("Please provide a positive number for the score amount.");
                return;
            }
            score += amount;
            updateScoreDisplay();
            console.log(`Added ${amount} score. Current score: ${score}`);
        };

        /**
         * Restores player health to maximum.
         */
        window.fullHeal = function() {
            playerHealth = playerMaxHealth;
            updateHealthDisplay();
            console.log("Player health fully restored!");
        };
    </script>
</body>
</html>
