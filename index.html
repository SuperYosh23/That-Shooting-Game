<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>That Shooting Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        /* Body base styles */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Tailwind gray-900 */
            color: #e2e8f0; /* Tailwind gray-300 */
            margin: 0;
            overflow: hidden; /* Prevent scrollbars from canvas */
            display: flex; /* Use flexbox for overall layout */
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            width: 100vw; /* Ensure body takes full viewport width */
            position: relative; /* For absolute positioning of gameContainer */
        }

        #gameContainer {
            position: absolute; /* Position absolutely to fill the background */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center; /* Center canvas vertically */
            background-color: #000; /* Canvas will be drawn over this, but good fallback */
            overflow: hidden; /* Ensure content is clipped */
            border-radius: 0; /* No border-radius on container, canvas is full screen */
            box-shadow: none; /* No shadow on container */
        }

        canvas {
            display: block;
            background-color: #000; /* Canvas background */
            width: 100%; /* Canvas fills its container */
            height: 100%; /* Canvas fills its container */
        }

        #uiContainer {
            position: absolute; /* Position UI over the canvas */
            top: 0;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            background: linear-gradient(to bottom, #2d3748, #1a202c); /* Gradient background */
            border-bottom: 1px solid #4a5568; /* Subtle border */
            box-shadow: 0 2px 5px rgba(0,0,0,0.2); /* Shadow for depth */
            z-index: 5; /* Ensure UI is above canvas */
        }

        #scoreBoard, #waveBoard {
            font-size: 1.25rem;
            font-weight: 700;
            color: #cbd5e0;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        #pauseButton, #settingsButtonInGame { /* Added settingsButtonInGame */
            padding: 0.5rem 1rem;
            font-size: 1rem;
            background: linear-gradient(to right, #63b3ed, #4299e1);
            color: white;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            font-weight: 600;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
            margin-right: 0.5rem; /* Space between buttons */
        }
        #pauseButton:hover, #settingsButtonInGame:hover {
            background: linear-gradient(to right, #4299e1, #3182ce);
            transform: translateY(-1px);
        }
        #pauseButton:active, #settingsButtonInGame:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        /* Message display (title screen, game over, pause, wave messages) */
        #messageDisplay {
            position: fixed; /* Always fixed to viewport */
            top: 0;
            left: 0;
            height: 100vh; /* Full viewport height */
            width: 300px; /* Fixed width for the panel */
            background-color: rgba(30, 41, 59, 0.95); /* Semi-transparent dark background */
            color: #e2e8f0;
            padding: 2rem;
            box-sizing: border-box; /* Include padding in width/height */
            display: flex;
            flex-direction: column;
            justify-content: center; /* Center content vertically */
            align-items: flex-start; /* Align content to the left */
            z-index: 10; /* Ensure it's on top of gameContainer and UI */
            box-shadow: 5px 0 15px rgba(0,0,0,0.5); /* Shadow on the right edge */
            border-right: 1px solid #4a5568; /* Subtle border on the right */
            text-align: left; /* Default text alignment for panel content */
        }

        #messageDisplay #messageText {
            font-size: 2.8rem; /* Larger title font */
            font-weight: 800;
            margin-bottom: 2rem;
            width: 100%;
            text-align: left; /* Align title text to left */
            line-height: 1.1; /* Adjust line height for multi-line titles */
        }

        #messageDisplay button {
            width: 100%; /* Make buttons fill the panel width */
            margin-top: 1rem;
            padding: 0.75rem 1.75rem;
            font-size: 1.1rem;
            background: linear-gradient(to right, #4299e1, #63b3ed);
            color: white;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            font-weight: 700;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        #messageDisplay button:hover {
            background: linear-gradient(to right, #3182ce, #4299e1);
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0,0,0,0.3);
        }
        #messageDisplay button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        /* Small overlay messages (pause, wave incoming) - these should be centered */
        #messageDisplay.overlay-message {
            position: absolute; /* Revert to absolute for centering within gameContainer */
            width: auto; /* Auto width for content */
            height: auto; /* Auto height for content */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 2.5rem 3rem;
            text-align: center; /* Center text for overlay messages */
            border-radius: 0.75rem;
            box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5);
            border: 1px solid #4a5568;
            background-color: rgba(30, 41, 59, 0.95);
        }
        #messageDisplay.overlay-message #messageText {
            font-size: 1.8rem; /* Smaller font for overlay messages */
            text-align: center;
            margin-bottom: 0; /* No margin for simple messages */
        }
        #messageDisplay.overlay-message button {
            display: none; /* Hide buttons for simple overlay messages like "Game Paused" */
        }

        /* Touch controls */
        .touch-controls {
            display: none; /* Controlled via JS toggle or media query */
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 92%;
            max-width: 480px;
            z-index: 20;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
        }
        .touch-controls.active {
            display: flex; /* Force show when enabled via settings */
        }
        .touch-controls button {
            background: linear-gradient(to bottom, #4a5568, #2d3748);
            color: white;
            border: 2px solid #a0aec0;
            border-radius: 50%;
            width: 72px;
            height: 72px;
            font-size: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
            box-shadow: 0 6px 10px rgba(0,0,0,0.4);
            transition: transform 0.08s ease-out, opacity 0.08s ease-out;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            opacity: 0.95;
        }
        .touch-controls button:active {
            transform: scale(0.92);
            opacity: 0.85;
        }
        @media (hover: none) and (pointer: coarse) {
            .touch-controls {
                display: flex; /* Auto-show on mobile */
            }
        }

        /* Shop specific styles */
        #shopDisplay {
            position: fixed; /* Keep it fixed for overlay behavior */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(30, 41, 59, 0.98);
            color: #e2e8f0;
            padding: 2.5rem 3rem;
            border-radius: 0.75rem;
            text-align: center;
            font-size: 1.3rem;
            z-index: 15;
            display: none;
            width: 85%;
            max-width: 450px;
            box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5);
            border: 1px solid #4a5568;
        }

        #shopDisplay h2 {
            font-size: 2.2rem;
            font-weight: bold;
            margin-bottom: 2rem;
            color: #a0aec0;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        #shopItemsContainer {
            display: flex;
            flex-direction: column;
            gap: 1.25rem;
        }

        .shop-item-button {
            background: linear-gradient(to right, #63b3ed, #4299e1);
            color: #1a202c;
            padding: 0.85rem 1.75rem;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            font-size: 1.2rem;
            font-weight: 700;
            transition: all 0.2s ease-in-out;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
        }

        .shop-item-button:hover {
            background: linear-gradient(to right, #4299e1, #3182ce);
            transform: translateY(-3px);
            box-shadow: 0 6px 8px rgba(0,0,0,0.3);
        }

        .shop-item-button:disabled {
            background: linear-gradient(to right, #718096, #5a67d8);
            cursor: not-allowed;
            opacity: 0.7;
            transform: none;
            box-shadow: none;
        }

        .shop-item-button .ml-4 {
            background: linear-gradient(to right, #48bb78, #38a169);
            color: white;
            padding: 0.6rem 1.2rem;
            border-radius: 0.4rem;
            font-size: 1rem;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .shop-item-button .ml-4:hover:enabled {
            background: linear-gradient(to right, #38a169, #2f855a);
            transform: translateY(-1px);
        }
        .shop-item-button .ml-4:active:enabled {
            transform: translateY(0);
        }

        #closeShopBtn {
            margin-top: 2.5rem;
            padding: 0.75rem 2.25rem;
            font-size: 1.1rem;
            background: linear-gradient(to right, #e53e3e, #c53030);
            color: white;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            font-weight: 700;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }

        #closeShopBtn:hover {
            background: linear-gradient(to right, #c53030, #9b2c2c);
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0,0,0,0.3);
        }
        #closeShopBtn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        /* Settings menu styles */
        #settingsDisplay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(30, 41, 59, 0.98);
            color: #e2e8f0;
            padding: 2.5rem 3rem;
            border-radius: 0.75rem;
            text-align: center;
            font-size: 1.3rem;
            z-index: 20; /* Higher z-index than shop */
            display: none;
            width: 85%;
            max-width: 450px;
            box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5);
            border: 1px solid #4a5568;
        }

        #settingsDisplay h2 {
            font-size: 2.2rem;
            font-weight: bold;
            margin-bottom: 2rem;
            color: #a0aec0;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            background-color: #4a5568; /* Slightly darker background for setting item */
            padding: 1rem 1.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .setting-item label {
            font-size: 1.1rem;
            font-weight: 600;
            color: #cbd5e0;
        }

        /* Toggle Switch Styling */
        .switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #ccc;
            transition: .25s;
            border-radius: 34px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 26px; width: 26px;
            left: 4px; bottom: 4px;
            background-color: white;
            transition: .25s;
            border-radius: 50%;
        }
        input:checked + .slider { background-color: #48bb78; }
        input:focus + .slider { box-shadow: 0 0 1px #48bb78; }
        input:checked + .slider:before { transform: translateX(26px); }
        .slider.round { border-radius: 34px; }
        .slider.round:before { border-radius: 50%; }

        #closeSettingsBtn {
            margin-top: 2.5rem;
            padding: 0.75rem 2.25rem;
            font-size: 1.1rem;
            background: linear-gradient(to right, #e53e3e, #c53030);
            color: white;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            font-weight: 700;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        #closeSettingsBtn:hover { background: linear-gradient(to right, #c53030, #9b2c2c); transform: translateY(-2px); box-shadow: 0 6px 8px rgba(0,0,0,0.3); }
        #closeSettingsBtn:active { transform: translateY(0); box-shadow: 0 2px 4px rgba(0,0,0,0.2); }

        /* How To Play menu styles */
        #howToPlayDisplay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(30, 41, 59, 0.98);
            color: #e2e8f0;
            padding: 2.5rem 3rem;
            border-radius: 0.75rem;
            text-align: center;
            font-size: 1.3rem;
            z-index: 20; /* Higher z-index than shop */
            display: none;
            width: 85%;
            max-width: 450px;
            box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5);
            border: 1px solid #4a5568;
        }

        #howToPlayDisplay h2 {
            font-size: 2.2rem;
            font-weight: bold;
            margin-bottom: 1.5rem;
            color: #a0aec0;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        #howToPlayDisplay p {
            margin-bottom: 1rem;
            font-size: 1.1rem;
            line-height: 1.5;
            text-align: left;
        }

        #howToPlayDisplay button {
            margin-top: 2rem;
            padding: 0.75rem 2.25rem;
            font-size: 1.1rem;
            background: linear-gradient(to right, #4299e1, #63b3ed);
            color: white;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            font-weight: 700;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
            width: 100%;
        }
        #howToPlayDisplay button:hover { background: linear-gradient(to right, #3182ce, #4299e1); transform: translateY(-2px); box-shadow: 0 6px 8px rgba(0,0,0,0.3); }
        #howToPlayDisplay button:active { transform: translateY(0); box-shadow: 0 2px 4px rgba(0,0,0,0.2); }

        /* Credits and GitHub Icon styles */
        #credits {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-size: 0.9rem;
            color: #a0aec0;
            z-index: 10;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        #githubLink {
            position: absolute;
            bottom: 10px;
            right: 10px;
            font-size: 1.5rem;
            color: #a0aec0;
            z-index: 10;
            transition: color 0.2s ease-in-out;
        }
        #githubLink:hover { color: #e2e8f0; }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>

        <div id="uiContainer" class="hidden">
            <div class="flex items-center">
                <button id="pauseButton" class="hidden">Pause</button>
                <button id="settingsButtonInGame" class="hidden">Settings</button>
            </div>
            <div id="scoreBoard">Score: 0</div>
            <div id="waveBoard">Wave: 1</div>
            <button id="shopButton" class="px-4 py-2 bg-purple-600 text-white rounded-md font-semibold hover:bg-purple-700 transition-colors">Shop</button>
            <div id="healthBarDisplay" class="w-32 h-6 bg-red-700 rounded-full overflow-hidden border-2 border-gray-400">
                <div id="currentHealthBar" class="h-full bg-green-500 transition-all duration-100 ease-out"></div>
            </div>
        </div>

        <div id="credits">
            <div>Made by SuperYosh23 and Google Gemini</div>
        </div>
        <a id="githubLink" href="https://github.com/SuperYosh23" target="_blank" aria-label="My GitHub Profile">
            <i class="fab fa-github"></i>
        </a>
    </div>

    <div id="messageDisplay">
        <p id="messageText"></p>
        <button id="startButton" class="hidden">Start Game</button>
        <button id="restartButton" class="hidden">Restart Game</button>
        <button id="howToPlayButtonTitle" class="hidden">How To Play</button>
        <button id="settingsButtonTitle" class="hidden">Settings</button>
    </div>

    <div id="shopDisplay" class="hidden">
        <h2>Shop</h2>
        <div id="shopItemsContainer"></div>
        <p class="mt-4 text-lg">Your Score: <span id="shopScore" class="font-bold text-yellow-300">0</span></p>
        <button id="closeShopBtn">Close Shop</button>
    </div>

    <div id="settingsDisplay" class="hidden">
        <h2>Settings</h2>
        <div class="setting-item">
            <label for="soundToggle">Sound Effects</label>
            <label class="switch">
                <input type="checkbox" id="soundToggle" checked>
                <span class="slider round"></span>
            </label>
        </div>
        <div class="setting-item">
            <label for="starsToggle">Background Stars</label>
            <label class="switch">
                <input type="checkbox" id="starsToggle" checked>
                <span class="slider round"></span>
            </label>
        </div>
        <div class="setting-item">
            <label for="hitboxToggle">Show Hitboxes</label>
            <label class="switch">
                <input type="checkbox" id="hitboxToggle">
                <span class="slider round"></span>
            </label>
        </div>
        <!-- NEW: Enable Touch Controls toggle for desktop testing -->
        <div class="setting-item">
            <label for="touchToggle">Enable Touch Controls</label>
            <label class="switch">
                <input type="checkbox" id="touchToggle">
                <span class="slider round"></span>
            </label>
        </div>
        <button id="closeSettingsBtn">Close Settings</button>
    </div>

    <div id="howToPlayDisplay" class="hidden">
        <h2>How To Play</h2>
        <p><strong>Objective:</strong> Survive endless waves of alien enemies and defeat powerful bosses!</p>
        <p><strong>Movement:</strong> Use <strong>WASD</strong> or <strong>Arrow Keys</strong> to move your ship.</p>
        <p><strong>Aim & Shoot:</strong> Move your <strong>Mouse</strong> to aim, and <strong>Click</strong> or press <strong>Spacebar</strong> to shoot.</p>
        <p><strong>Shop:</strong> Spend points earned from defeating enemies to upgrade your ship. The shop opens between waves and after boss fights.</p>
        <p><strong>Health:</strong> Keep an eye on your health bar! Pick up health packs from the shop to restore health.</p>
        <p><strong>Pause:</strong> Press <strong>ESC</strong> to pause the game at any time.</p>
        <button id="closeHowToPlayBtn">Back to Title</button>
    </div>

    <div class="touch-controls">
        <button id="touchLeftBtn">â—€</button>
        <button id="touchShootBtn">ðŸ’¥</button>
        <button id="touchRightBtn">â–¶</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreBoard = document.getElementById('scoreBoard');
        const waveBoard = document.getElementById('waveBoard');
        const messageDisplay = document.getElementById('messageDisplay');
        const messageText = document.getElementById('messageText');
        const startButton = document.getElementById('startButton');
        const restartButton = document.getElementById('restartButton');
        const settingsButtonTitle = document.getElementById('settingsButtonTitle');
        const settingsButtonInGame = document.getElementById('settingsButtonInGame');
        const howToPlayButtonTitle = document.getElementById('howToPlayButtonTitle');

        const shopDisplay = document.getElementById('shopDisplay');
        const shopItemsContainer = document.getElementById('shopItemsContainer');
        const shopScoreDisplay = document.getElementById('shopScore');
        const closeShopBtn = document.getElementById('closeShopBtn');
        const shopButton = document.getElementById('shopButton');
        const pauseButton = document.getElementById('pauseButton');

        const settingsDisplay = document.getElementById('settingsDisplay');
        const soundToggle = document.getElementById('soundToggle');
        const starsToggle = document.getElementById('starsToggle');
        const hitboxToggle = document.getElementById('hitboxToggle');
        const closeSettingsBtn = document.getElementById('closeSettingsBtn');

        const howToPlayDisplay = document.getElementById('howToPlayDisplay');
        const closeHowToPlayBtn = document.getElementById('closeHowToPlayBtn');

        const touchControls = document.querySelector('.touch-controls');
        const touchLeftBtn = document.getElementById('touchLeftBtn');
        const touchRightBtn = document.getElementById('touchRightBtn');
        const touchShootBtn = document.getElementById('touchShootBtn');
        const touchToggle = document.getElementById('touchToggle');

        // New references for the health bar elements
        const healthBarDisplay = document.getElementById('healthBarDisplay');
        const currentHealthBar = document.getElementById('currentHealthBar');

        let gameWidth, gameHeight;

        let score = 0;
        let playerHealth = 75; // Changed playerHealth default to 75
        const playerMaxHealth = 75; // Changed playerMaxHealth to 75
        let wave = 1;
        let enemiesRequiredForWave = 15;
        let enemiesDefeatedInWave = 0;
        var wavesPerBoss = 5;
        let gameRunning = false;
        let shopOpen = false;
        let bossActive = false;
        let paused = false;
        let wasGameRunningBeforeShop = false;
        let wasGameRunningBeforeSettings = false;
        let wasGameRunningBeforeHowToPlay = false;
        let soundEnabled = true;
        let starsEnabled = true;
        let showHitboxes = false;
        let settingsOpen = false;
        let howToPlayOpen = false;
        let isTransitioningFromMenu = false;
        let touchControlsEnabled = false; // NEW: manual toggle for touch controls

        let animationFrameId;
        let titleAnimationId;

        let bossFightsCompleted = 0;
        const baseEnemySpeed = 2;
        const speedIncreasePerBoss = 1.0;
        const baseSpawnInterval = 1500;
        const spawnIntervalDecreasePerWave = 75;
        const basePlayerSpeed = 7; // Define base player speed
        const playerSpeedIncreasePerBoss = 0.5; // Amount player speed increases after each boss

        const mouse = { x: 0, y: 0, isOverCanvas: false };

        let MAX_AIM_DISTANCE = 250;
        const MAX_AIM_ANGLE_RADIANS = Math.PI / 6;

        const player = {
            x: 0, y: 0,
            width: 50, height: 50,
            hitboxWidth: 40, hitboxHeight: 45,
            color: '#4299e1',
            currentAngle: -Math.PI / 2,
            targetAngle: -Math.PI / 2,
            rotationSpeed: 1.0,
            dx: 0, dy: 0,
            initialY: 0,
            titleAnimationOffset: 0,
            titleAnimationDirection: 1,
            titleAnimationSpeed: 0.5,
            titleAnimationMaxOffset: 10,
            draw: function() {
                ctx.save();
                ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
                ctx.rotate(this.currentAngle + Math.PI / 2);
                const bodyGradient = ctx.createLinearGradient(-this.width / 2, -this.height / 2, this.width / 2, this.height / 2);
                bodyGradient.addColorStop(0, '#4299e1'); bodyGradient.addColorStop(0.5, '#63b3ed'); bodyGradient.addColorStop(1, '#4299e1');
                ctx.fillStyle = bodyGradient;
                ctx.beginPath();
                ctx.moveTo(0, -this.height / 2);
                ctx.lineTo(-this.width * 0.4, this.height * 0.2);
                ctx.lineTo(-this.width * 0.3, this.height / 2);
                ctx.lineTo(this.width * 0.3, this.height / 2);
                ctx.lineTo(this.width * 0.4, this.height * 0.2);
                ctx.closePath(); ctx.fill();
                ctx.fillStyle = '#a78bfa'; ctx.beginPath(); ctx.arc(0, -this.height * 0.1, 8, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#f56565'; ctx.fillRect(-this.width * 0.2, this.height / 2 - 5, this.width * 0.15, 10); ctx.fillRect(this.width * 0.05, this.height / 2 - 5, this.width * 0.15, 10);
                if (gameRunning) {
                    const exhaustHeight = Math.random() * 10 + 5;
                    const exhaustGradient = ctx.createLinearGradient(0, this.height / 2, 0, this.height / 2 + exhaustHeight);
                    exhaustGradient.addColorStop(0, 'rgba(255, 165, 0, 0.8)');
                    exhaustGradient.addColorStop(0.5, 'rgba(255, 255, 0, 0.5)');
                    exhaustGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    ctx.fillStyle = exhaustGradient;
                    ctx.beginPath();
                    ctx.moveTo(-this.width * 0.2, this.height / 2);
                    ctx.lineTo(-this.width * 0.3, this.height / 2 + exhaustHeight);
                    ctx.lineTo(this.width * 0.3, this.height / 2 + exhaustHeight);
                    ctx.lineTo(this.width * 0.2, this.height / 2);
                    ctx.closePath(); ctx.fill();
                }
                ctx.restore();
            },
            speed: basePlayerSpeed,
        };

        const bullets = [];
        const bulletProps = {
            width: 5, height: 15, color: '#f56565',
            draw: function(bullet) {
                ctx.save();
                ctx.translate(bullet.x + this.width / 2, bullet.y + this.height / 2);
                ctx.rotate(bullet.angle + Math.PI / 2);
                ctx.fillStyle = this.color;
                ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                ctx.fillStyle = '#ff7777';
                ctx.fillRect(-this.width / 2 + 1, -this.height / 2 + 2, this.width - 2, this.height - 4);
                ctx.fillStyle = 'rgba(255, 200, 0, 0.5)';
                ctx.fillRect(-this.width / 2, this.height / 2, this.width, this.height * 0.5);
                ctx.restore();
            },
            speed: 10, cooldown: 250, lastShotTime: 0
        };

        const enemyTypes = [
            { name: 'small', width: 40, height: 30, health: 10, baseSpeed: baseEnemySpeed, colors: ['#48bb78', '#38a169', '#68d391'], canShoot: false, scoreValue: 10 },
            { name: 'medium', width: 60, height: 45, health: 20, baseSpeed: baseEnemySpeed * 0.8, colors: ['#f6ad55', '#ed8936', '#dd6b20'], canShoot: true, bulletSpeed: 5, shootCooldown: 3000, scoreValue: 30 },
            { name: 'large', width: 80, height: 60, health: 30, baseSpeed: baseEnemySpeed * 0.6, colors: ['#e53e3e', '#c53030', '#9b2c2c'], canShoot: true, bulletSpeed: 7, shootCooldown: 4000, scoreValue: 60 }
        ];

        const enemies = [];
        const enemyProps = { spawnInterval: baseSpawnInterval, lastSpawnTime: 0 };

        const enemyBullets = [];
        const enemyBulletProps = {
            width: 12, height: 12, color: '#FF0000',
            draw: function(bullet) {
                ctx.fillStyle = this.color;
                ctx.beginPath(); ctx.arc(bullet.x, bullet.y, this.width / 2, 0, Math.PI * 2); ctx.fill();
                const gradient = ctx.createRadialGradient(bullet.x, bullet.y, 0, bullet.x, bullet.y, this.width / 2 + 5);
                gradient.addColorStop(0, 'rgba(255, 0, 0, 0.8)'); gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath(); ctx.arc(bullet.x, bullet.y, this.width / 2 + 5, 0, Math.PI * 2); ctx.fill();
            },
            damage: 10
        };

        const boss = {
            x: 0, y: 0, width: 0, height: 0,
            health: 0, maxHealth: 0,
            speed: 1, dx: 1, color: '#e53e3e',
            bulletSpeed: 6, shootCooldown: 1000, lastShotTime: 0,
            draw: function() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.moveTo(this.x + this.width * 0.1, this.y);
                ctx.lineTo(this.x + this.width * 0.9, this.y);
                ctx.lineTo(this.x + this.width, this.y + this.height * 0.5);
                ctx.lineTo(this.x + this.width * 0.9, this.y + this.height);
                ctx.lineTo(this.x + this.width * 0.1, this.y + this.height);
                ctx.lineTo(this.x, this.y + this.height * 0.5);
                ctx.closePath(); ctx.fill();
                ctx.fillStyle = '#a0aec0';
                ctx.fillRect(this.x + this.width * 0.05, this.y + this.height * 0.3, 20, this.height * 0.4);
                ctx.fillRect(this.x + this.width * 0.95 - 20, this.y + this.height * 0.3, 20, this.height * 0.4);
                ctx.fillStyle = '#f6e05e';
                ctx.beginPath(); ctx.arc(this.x + this.width / 2, this.y + this.height / 2, 30, 0, Math.PI * 2); ctx.fill();
                const healthBarWidth = this.width * 0.8, healthBarHeight = 15;
                const healthBarX = this.x + (this.width - healthBarWidth) / 2, healthBarY = this.y - 25;
                ctx.fillStyle = '#c53030'; ctx.fillRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);
                const currentHealthWidth = (this.health / this.maxHealth) * healthBarWidth;
                ctx.fillStyle = '#48bb78'; ctx.fillRect(healthBarX, healthBarY, currentHealthWidth, healthBarHeight);
                ctx.strokeStyle = '#e2e8f0'; ctx.lineWidth = 1; ctx.strokeRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);
            }
        };

        const stars = [];
        const numStars = 150;
        const baseStarSpeed = 0.5; // Base speed for stars
        const starSpeedMultiplier = 0.1; // How much player speed affects star speed

        const flashEffect = { active: false, color: 'rgba(255, 0, 0, 0.3)', duration: 200, startTime: 0 };

        const aimIndicator = {
            x: 0, y: 0, radius: 8, color: '#FFFF00',
            draw: function() {
                ctx.fillStyle = this.color;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill();
                ctx.strokeStyle = '#FFFFFF'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.radius + 2, 0, Math.PI * 2); ctx.stroke();
            }
        };

        const shopItems = {
            'bulletSpeed': {
                id: 'bulletSpeed', name: 'Faster Bullets', baseCost: 100, currentLevel: 0, maxLevel: 3,
                effect: () => { bulletProps.speed += 2; },
                description: 'Increases bullet speed by 2.',
                getCost: function() { return Math.floor(this.baseCost * (1 + this.currentLevel * 0.5)); },
                getDisplayName: function() {
                    return this.currentLevel < this.maxLevel ? `${this.name} (Lv.${this.currentLevel + 1})` : `${this.name} (Max Lv.)`;
                }
            },
            'healthPack': {
                id: 'healthPack', name: 'Health Pack', baseCost: 200, currentLevel: 0,
                effect: () => { playerHealth = Math.min(playerMaxHealth, playerHealth + 50); updateHealthDisplay(); },
                description: 'Restores 50 health (max 100).',
                getCost: function() { return Math.floor(this.baseCost * (1 + this.currentLevel * 0.25)); },
                getDisplayName: function() { return this.name; }
            },
            'bulletRange': {
                id: 'bulletRange', name: 'Extended Range', baseCost: 120, currentLevel: 0, maxLevel: 3,
                effect: () => { MAX_AIM_DISTANCE += 50; },
                description: 'Increases bullet travel distance.',
                getCost: function() { return Math.floor(this.baseCost * (1 + this.currentLevel * 0.6)); },
                getDisplayName: function() {
                    return this.currentLevel < this.maxLevel ? `${this.name} (Lv.${this.currentLevel + 1})` : `${this.name} (Max Lv.)`;
                }
            }
        };

        // --- Tone.js Sound Effects ---
        const playerSynth = new Tone.Synth({
            oscillator: { type: "triangle" },
            envelope: { attack: 0.001, decay: 0.1, sustain: 0.05, release: 0.1 },
            volume: -10
        }).toDestination();

        const enemySynth = new Tone.Synth({
            oscillator: { type: "sine" },
            envelope: { attack: 0.01, decay: 0.2, sustain: 0.05, release: 0.2 },
            volume: -15
        }).toDestination();

        function playPlayerShootSound() { if (soundEnabled) playerSynth.triggerAttackRelease("C4", "8n"); }
        function playEnemyShootSound() { if (soundEnabled) enemySynth.triggerAttackRelease("A3", "8n"); }

        function toggleSound() {
            soundEnabled = soundToggle.checked;
            Tone.Master.mute = !soundEnabled; // Mute Tone.js master output if sound is disabled
            console.log("Sound Enabled:", soundEnabled);
        }
        function toggleStars() { starsEnabled = starsToggle.checked; console.log("Stars Enabled:", starsEnabled); }
        function toggleHitboxes() { showHitboxes = hitboxToggle.checked; console.log("Show Hitboxes:", showHitboxes); }

        // NEW: Touch controls toggle
        function applyTouchControlsVisibility() {
            // If settings toggle is ON, force show. Otherwise rely on media query (mobile) or hide.
            if (touchControlsEnabled) {
                touchControls.classList.add('active');
            } else {
                touchControls.classList.remove('active');
            }
        }
        function toggleTouchControls() {
            touchControlsEnabled = touchToggle.checked;
            applyTouchControlsVisibility();
            console.log("Touch Controls Enabled:", touchControlsEnabled);
        }

        function initializeStars() {
            stars.length = 0;
            for (let i = 0; i < numStars; i++) {
                stars.push({
                    x: Math.random() * gameWidth,
                    y: Math.random() * gameHeight,
                    radius: Math.random() * 2,
                    alpha: Math.random() * 0.7 + 0.3,
                    initialSpeed: Math.random() * 0.5 + 0.5
                });
            }
        }

        function drawStars() {
            if (!starsEnabled) return;
            ctx.fillStyle = '#ffffff';
            stars.forEach(star => {
                ctx.globalAlpha = star.alpha;
                ctx.beginPath(); ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2); ctx.fill();
            });
            ctx.globalAlpha = 1;
        }

        function updateStars() {
            if (!starsEnabled) return;
            const currentStarSpeed = baseStarSpeed + (player.speed * starSpeedMultiplier);
            stars.forEach(star => {
                star.y += star.initialSpeed * currentStarSpeed;
                if (star.y > gameHeight) { star.y = 0; star.x = Math.random() * gameWidth; }
            });
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gameWidth = canvas.width;
            gameHeight = canvas.height;
            console.log(`[Resize] Canvas resized to Width: ${gameWidth}, Height: ${gameHeight}`);
            player.x = gameWidth / 2 - player.width / 2;
            player.y = gameHeight - player.height - 50;
            player.initialY = player.y;
            messageDisplay.style.fontSize = `${Math.max(16, window.innerWidth / 50)}px`;
            shopDisplay.style.fontSize = `${Math.max(16, window.innerWidth / 60)}px`;
            settingsDisplay.style.fontSize = `${Math.max(16, window.innerWidth / 60)}px`;
            howToPlayDisplay.style.fontSize = `${Math.max(16, window.innerWidth / 60)}px`;
            initializeStars();
        }

        function drawPlayer() { player.draw(); }

        // NEW: Function to draw player hitbox for debugging
        function drawPlayerHitbox() {
            if (!showHitboxes) return;
            ctx.strokeStyle = 'lime'; ctx.lineWidth = 2;
            const playerHitboxX = player.x + (player.width - player.hitboxWidth) / 2;
            const playerHitboxY = player.y + (player.height - player.hitboxHeight) / 2;
            ctx.strokeRect(playerHitboxX, playerHitboxY, player.hitboxWidth, player.hitboxHeight);
        }

        function drawBullet(bullet) { bulletProps.draw(bullet); }

        function drawGenericEnemy(enemy) {
            try {
                const type = enemy.type;
                if (!type) { console.error("[Draw Enemy] Enemy type is undefined:", enemy); return; }
                const color = type.colors[0];
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(enemy.x + type.width / 2, enemy.y);
                ctx.lineTo(enemy.x, enemy.y + type.height * 0.3);
                ctx.lineTo(enemy.x, enemy.y + type.height * 0.7);
                ctx.lineTo(enemy.x + type.width / 2, enemy.y + type.height);
                ctx.lineTo(enemy.x + type.width, enemy.y + type.height * 0.7);
                ctx.lineTo(enemy.x + type.width, enemy.y + type.height * 0.3);
                ctx.closePath(); ctx.fill();
                ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.lineWidth = 1; ctx.stroke();

                const eyeCenterX = enemy.x + type.width / 2;
                const eyeCenterY = enemy.y + type.height / 2;
                const eyeRadius = 8 * (type.width / 40);

                const glowGradient = ctx.createRadialGradient(eyeCenterX, eyeCenterY, 0, eyeCenterX, eyeCenterY, eyeRadius + 5);
                glowGradient.addColorStop(0, 'rgba(255, 255, 0, 0.8)');
                glowGradient.addColorStop(1, 'rgba(255, 255, 0, 0)');
                ctx.fillStyle = glowGradient;
                ctx.beginPath(); ctx.arc(eyeCenterX, eyeCenterY, eyeRadius + 5, 0, Math.PI * 2); ctx.fill();

                ctx.fillStyle = '#f7fafc'; ctx.beginPath(); ctx.arc(eyeCenterX, eyeCenterY, eyeRadius, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#2d3748'; ctx.beginPath(); ctx.arc(eyeCenterX, eyeCenterY, eyeRadius * 0.4, 0, Math.PI * 2); ctx.fill();

                if (type.health > 10) {
                    const healthBarWidth = type.width * 0.8, healthBarHeight = 5;
                    const healthBarX = enemy.x + (type.width - healthBarWidth) / 2, healthBarY = enemy.y - 10;
                    ctx.fillStyle = '#c53030'; ctx.fillRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);
                    const currentHealthWidth = (enemy.health / type.health) * healthBarWidth;
                    ctx.fillStyle = '#48bb78'; ctx.fillRect(healthBarX, healthBarY, currentHealthWidth, healthBarHeight);
                    ctx.strokeStyle = '#e2e8f0'; ctx.lineWidth = 1; ctx.strokeRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);
                }
                // console.log(`[Draw Enemy] Drawing ${type.name} enemy at (${enemy.x}, ${enemy.y})`);
            } catch (error) {
                console.error("[Draw Enemy] Error drawing enemy:", enemy, error);
            }
        }

        function shootEnemyBullet(enemy) {
            const currentTime = Date.now();
            if (currentTime - enemy.lastShotTime > enemy.type.shootCooldown) {
                const startX = enemy.x + enemy.type.width / 2;
                const startY = enemy.y + enemy.type.height;
                const playerCenterX = player.x + player.width / 2;
                const playerCenterY = player.y + player.height / 2;
                const angle = Math.atan2(playerCenterY - startY, playerCenterX - startX);
                const bulletDx = enemy.type.bulletSpeed * Math.cos(angle);
                const bulletDy = enemy.type.bulletSpeed * Math.sin(angle);
                enemyBullets.push({ x: startX, y: startY, dx: bulletDx, dy: bulletDy, angle });
                enemy.lastShotTime = currentTime;
                playEnemyShootSound();
            }
        }

        function shootBossBullet(boss) {
            const currentTime = Date.now();
            if (currentTime - boss.lastShotTime > boss.shootCooldown) {
                const startX = boss.x + boss.width / 2;
                const startY = boss.y + boss.height;
                const playerCenterX = player.x + player.width / 2;
                const playerCenterY = player.y + player.height / 2;
                const angle = Math.atan2(playerCenterY - startY, playerCenterX - startX);
                const bulletDx = boss.bulletSpeed * Math.cos(angle);
                const bulletDy = boss.bulletSpeed * Math.sin(angle);
                enemyBullets.push({ x: startX, y: startY, dx: bulletDx, dy: bulletDy, angle });
                boss.lastShotTime = currentTime;
                playEnemyShootSound();
            }
        }

        function updatePlayer() {
            player.x += player.dx;
            player.y += player.dy;
            if (player.x < 0) player.x = 0;
            if (player.x + player.width > gameWidth) player.x = gameWidth - player.width;
            if (player.y < 0) player.y = 0;
            if (player.y + player.height > gameHeight) player.y = gameHeight - player.height;
        }

        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.x += bullet.dx;
                bullet.y += bullet.dy;
                const currentDistanceSq = (bullet.x + bulletProps.width/2 - bullet.startX)**2 + (bullet.y + bulletProps.height/2 - bullet.startY)**2;
                if (currentDistanceSq >= bullet.totalTargetDistanceSq ||
                    bullet.y + bulletProps.height < 0 || bullet.y > gameHeight ||
                    bullet.x + bulletProps.width < 0 || bullet.x > gameWidth) {
                    bullets.splice(i, 1);
                }
            }
        }

        function updateEnemyBullets() {
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const bullet = enemyBullets[i];
                bullet.x += bullet.dx;
                bullet.y += bullet.dy;
                if (bullet.y > gameHeight || bullet.x < 0 || bullet.x > gameWidth) {
                    enemyBullets.splice(i, 1);
                }
            }
        }

        const enemySpawnWeights = { 'small': 5, 'medium': 2, 'large': 1 };

        function spawnEnemy() {
            const currentTime = Date.now();
            if (bossActive) {
                const selectedEnemyType = enemyTypes[0];
                const x = Math.random() * (gameWidth - selectedEnemyType.width);
                const y = -selectedEnemyType.height;
                enemies.push({ x, y, type: selectedEnemyType, health: selectedEnemyType.health, lastShotTime: currentTime });
                enemyProps.lastSpawnTime = currentTime;
                return;
            }
            if (currentTime - enemyProps.lastSpawnTime > enemyProps.spawnInterval) {
                let currentWeights = {};
                if (wave <= 1) currentWeights = { 'small': enemySpawnWeights.small };
                else if (wave <= 3) currentWeights = { 'small': enemySpawnWeights.small, 'medium': enemySpawnWeights.medium };
                else currentWeights = enemySpawnWeights;

                let weightedEnemyTypes = [];
                for (const typeName in currentWeights) {
                    const weight = currentWeights[typeName];
                    const enemyType = enemyTypes.find(et => et.name === typeName);
                    if (enemyType) for (let i = 0; i < weight; i++) weightedEnemyTypes.push(enemyType);
                }
                if (weightedEnemyTypes.length === 0) return;

                const selectedEnemyType = weightedEnemyTypes[Math.floor(Math.random() * weightedEnemyTypes.length)];
                const x = Math.random() * (gameWidth - selectedEnemyType.width);
                const y = -selectedEnemyType.height;

                enemies.push({ x, y, type: selectedEnemyType, health: selectedEnemyType.health, lastShotTime: currentTime });
                enemyProps.lastSpawnTime = currentTime;
            }
        }

        function updateEnemies() {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                if (!enemy || !enemy.type) { enemies.splice(i, 1); continue; }
                enemy.y += enemy.type.baseSpeed + (bossFightsCompleted * speedIncreasePerBoss);
                if (enemy.type.canShoot) shootEnemyBullet(enemy);
                if (enemy.y + enemy.type.height > gameHeight) enemies.splice(i, 1);
            }
        }

        function updateBoss() {
            if (!bossActive) return;
            boss.x += boss.dx;
            if (boss.x < 0 || boss.x + boss.width > gameWidth) boss.dx *= -1;
            if (boss.y < gameHeight * 0.2) boss.y += boss.speed * 0.5;
            shootBossBullet(boss);
        }

        function checkCollisions() {
            const playerHitboxX = player.x + (player.width - player.hitboxWidth) / 2;
            const playerHitboxY = player.y + (player.height - player.hitboxHeight) / 2;

            // Player bullets vs. Enemies
            for (let i = bullets.length - 1; i >= 0; i--) {
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const bullet = bullets[i], enemy = enemies[j];
                    if (bullet && enemy &&
                        bullet.x < enemy.x + enemy.type.width &&
                        bullet.x + bulletProps.width > enemy.x &&
                        bullet.y < enemy.y + enemy.type.height &&
                        bullet.y + bulletProps.height > enemy.y) {
                        bullets.splice(i, 1);
                        enemy.health -= 10;
                        if (enemy.health <= 0) {
                            enemies.splice(j, 1);
                            score += enemy.type.scoreValue;
                            enemiesDefeatedInWave++;
                            updateScoreDisplay();
                            if (!bossActive && enemiesDefeatedInWave >= enemiesRequiredForWave) {
                                wave++;
                                enemiesDefeatedInWave = 0;
                                enemyProps.spawnInterval = Math.max(50, baseSpawnInterval - ((wave - 1) % wavesPerBoss) * spawnIntervalDecreasePerWave);
                                updateScoreDisplay();
                                showOverlayMessage(`Wave ${wave} Incoming!`);
                                if ((wave - 1) % wavesPerBoss === 0 && wave > 1) {
                                    enemies.length = 0;
                                    startBossFight();
                                }
                            }
                        }
                        break;
                    }
                }
            }

            // Player bullets vs. Boss
            if (bossActive) {
                for (let i = bullets.length - 1; i >= 0; i--) {
                    const bullet = bullets[i];
                    if (bullet.x < boss.x + boss.width &&
                        bullet.x + bulletProps.width > boss.x &&
                        bullet.y < boss.y + boss.height &&
                        bullet.y + bulletProps.height > boss.y) {
                        bullets.splice(i, 1);
                        boss.health -= 1;
                        updateBossHealthDisplay();
                        if (boss.health <= 0) defeatBoss();
                        break;
                    }
                }
            }

            // Player vs. Enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                if (playerHitboxX < enemy.x + enemy.type.width &&
                    playerHitboxX + player.hitboxWidth > enemy.x &&
                    playerHitboxY < enemy.y + enemy.type.height &&
                    playerHitboxY + player.hitboxHeight > enemy.y) {
                    enemies.splice(i, 1);
                    takeDamage(5, 'enemy collision');
                    break;
                }
            }

            // Player vs. Enemy Bullets
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const eBullet = enemyBullets[i];
                if (eBullet.x < playerHitboxX + player.hitboxWidth &&
                    eBullet.x + enemyBulletProps.width > playerHitboxX &&
                    eBullet.y < playerHitboxY + player.hitboxHeight &&
                    eBullet.y + enemyBulletProps.height > playerHitboxY) {
                    enemyBullets.splice(i, 1);
                    takeDamage(enemyBulletProps.damage, 'enemy bullet');
                    break;
                }
            }

            // Player vs. Boss
            if (bossActive) {
                if (playerHitboxX < boss.x + boss.width &&
                    playerHitboxX + player.hitboxWidth > boss.x &&
                    playerHitboxY < boss.y + boss.height &&
                    playerHitboxY + player.hitboxHeight > boss.y) {
                    takeDamage(50, 'boss collision');
                }
            }
        }

        function shoot() {
            const currentTime = Date.now();
            if (currentTime - bulletProps.lastShotTime > bulletProps.cooldown) {
                const startX = player.x + player.width / 2;
                const startY = player.y + player.height / 2;
                const targetX = aimIndicator.x;
                const targetY = aimIndicator.y;
                const deltaX = targetX - startX;
                const deltaY = targetY - startY;
                const angle = Math.atan2(deltaY, deltaX);
                const bulletDx = bulletProps.speed * Math.cos(angle);
                const bulletDy = bulletProps.speed * Math.sin(angle);
                const totalTargetDistanceSq = (targetX - startX)**2 + (targetY - startY)**2;
                bullets.push({
                    x: startX - bulletProps.width / 2,
                    y: startY - bulletProps.height / 2,
                    dx: bulletDx, dy: bulletDy,
                    startX, startY,
                    totalTargetDistanceSq: totalTargetDistanceSq,
                    angle
                });
                bulletProps.lastShotTime = currentTime;
                playPlayerShootSound();
            }
        }

        function updateScoreDisplay() {
            scoreBoard.textContent = `Score: ${score}`;
            waveBoard.textContent = `Wave: ${wave}`;
        }

        function updateHealthDisplay() {
            const healthPercentage = (playerHealth / playerMaxHealth) * 100;
            currentHealthBar.style.width = `${healthPercentage}%`;
            if (healthPercentage > 50) currentHealthBar.style.backgroundColor = '#48bb78';
            else if (healthPercentage > 20) currentHealthBar.style.backgroundColor = '#f6ad55';
            else currentHealthBar.style.backgroundColor = '#e53e3e';
            console.log(`[Health Update] Player Health: ${playerHealth}/${playerMaxHealth}`);
        }

        function updateBossHealthDisplay() { console.log(`[Boss Health] Boss Health: ${boss.health}/${boss.maxHealth}`); }

        function takeDamage(amount, reason = 'unknown cause') {
            console.log(`[Damage] Player took ${amount} damage due to: ${reason}`);
            playerHealth -= amount;
            if (playerHealth < 0) playerHealth = 0;
            updateHealthDisplay();
            flashEffect.active = true;
            flashEffect.startTime = Date.now();
            if (playerHealth <= 0) gameOver();
        }

        function gameOver() {
            console.log("[Game Over] Game Over initiated.");
            gameRunning = false; bossActive = false; paused = false;
            shopOpen = false; settingsOpen = false; howToPlayOpen = false;
            cancelAnimationFrame(animationFrameId); animationFrameId = null;
            messageText.textContent = `Game Over! Final Score: ${score}`;
            messageDisplay.style.display = 'flex';
            startButton.classList.add('hidden');
            restartButton.classList.remove('hidden');
            howToPlayButtonTitle.classList.remove('hidden');
            settingsButtonTitle.classList.remove('hidden');
            messageDisplay.classList.remove('overlay-message');

            uiContainer.classList.add('hidden');
            scoreBoard.classList.add('hidden');
            waveBoard.classList.add('hidden');
            healthBarDisplay.classList.add('hidden');
            shopButton.classList.add('hidden');
            pauseButton.classList.add('hidden');
            settingsButtonInGame.classList.add('hidden');
            shopDisplay.style.display = 'none';
            settingsDisplay.style.display = 'none';
            howToPlayDisplay.style.display = 'none';

            startTitleAnimation();
        }

        function showOverlayMessage(message) {
            console.log(`[Overlay Message] Showing: "${message}"`);
            messageText.textContent = message;
            messageDisplay.style.display = 'block';
            messageDisplay.classList.add('overlay-message');
            startButton.classList.add('hidden');
            restartButton.classList.add('hidden');
            howToPlayButtonTitle.classList.add('hidden');
            settingsButtonTitle.classList.add('hidden');
            setTimeout(() => {
                messageDisplay.style.display = 'none';
                messageDisplay.classList.remove('overlay-message');
            }, 2000);
        }

        function startBossFight() {
            console.log("[Boss Fight] Starting boss fight!");
            bossActive = true;
            enemies.length = 0;
            boss.maxHealth = 100 + (Math.floor(wave / wavesPerBoss) - 1) * 100;
            boss.health = boss.maxHealth;
            boss.width = gameWidth * 0.6;
            boss.height = 80;
            boss.x = gameWidth / 2 - boss.width / 2;
            boss.y = -boss.height;
            boss.speed = 1 + (Math.floor(wave / wavesPerBoss) - 1) * 0.5;
            boss.dx = boss.speed;
            boss.lastShotTime = Date.now();
            updateBossHealthDisplay();
            showOverlayMessage("BOSS BATTLE INCOMING!");
        }

        function defeatBoss() {
            console.log("[Boss Fight] Boss defeated!");
            bossActive = false;
            score += 500;
            updateScoreDisplay();
            showOverlayMessage(`Boss Defeated! Wave ${wave + 1} Incoming!`);
            bossFightsCompleted++;
            player.speed += playerSpeedIncreasePerBoss;
            enemyProps.spawnInterval = baseSpawnInterval;
            wave++;
            enemiesDefeatedInWave = 0;
            enemiesRequiredForWave = 15;
            enemies.length = 0;
            enemyBullets.length = 0;
        }

        function startGame() {
            console.log("startGame called.");
            if (titleAnimationId) { cancelAnimationFrame(titleAnimationId); titleAnimationId = null; }

            score = 0;
            playerHealth = playerMaxHealth;
            wave = 1;
            enemiesRequiredForWave = 15;
            enemiesDefeatedInWave = 0;
            gameRunning = true; shopOpen = false; bossActive = false; paused = false;
            settingsOpen = false; howToPlayOpen = false;
            bullets.length = 0; enemies.length = 0; enemyBullets.length = 0;

            bossFightsCompleted = 0;
            enemyProps.spawnInterval = baseSpawnInterval;
            enemyProps.lastSpawnTime = Date.now();

            bulletProps.lastShotTime = 0;
            player.dx = 0; player.dy = 0;
            player.currentAngle = -Math.PI / 2;
            player.targetAngle = -Math.PI / 2;
            player.y = player.initialY;
            player.titleAnimationOffset = 0;

            MAX_AIM_DISTANCE = 250;
            for (const key in shopItems) { if (shopItems[key].currentLevel !== undefined) shopItems[key].currentLevel = 0; }
            player.speed = basePlayerSpeed;
            bulletProps.speed = 10;

            updateScoreDisplay();
            updateHealthDisplay();
            resizeCanvas();

            messageDisplay.style.display = 'none';
            messageDisplay.classList.remove('overlay-message');

            startButton.classList.add('hidden');
            restartButton.classList.add('hidden');
            howToPlayButtonTitle.classList.add('hidden');
            settingsButtonTitle.classList.add('hidden');
            settingsDisplay.style.display = 'none';
            howToPlayDisplay.style.display = 'none';

            uiContainer.classList.remove('hidden');
            scoreBoard.classList.remove('hidden');
            waveBoard.classList.remove('hidden');
            healthBarDisplay.classList.remove('hidden');
            shopButton.classList.remove('hidden');
            pauseButton.classList.remove('hidden');
            settingsButtonInGame.classList.remove('hidden');

            // Apply touch controls visibility in case it's enabled
            applyTouchControlsVisibility();

            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            animationFrameId = requestAnimationFrame(gameLoopWithInput);
            console.log("startGame finished. gameRunning:", gameRunning);
        }

        function pauseGame() {
            if (!gameRunning || paused || shopOpen || settingsOpen || howToPlayOpen) return;
            paused = true;
            cancelAnimationFrame(animationFrameId); animationFrameId = null;
            showOverlayMessage("Game Paused");
            uiContainer.classList.add('hidden');
            scoreBoard.classList.add('hidden');
            waveBoard.classList.add('hidden');
            healthBarDisplay.classList.add('hidden');
            shopButton.classList.add('hidden');
            pauseButton.classList.add('hidden');
            settingsButtonInGame.classList.add('hidden');
        }

        function resumeGame() {
            if (!gameRunning || !paused || shopOpen || settingsOpen || howToPlayOpen) return;
            paused = false;
            messageDisplay.style.display = 'none';
            messageDisplay.classList.remove('overlay-message');
            uiContainer.classList.remove('hidden');
            scoreBoard.classList.remove('hidden');
            waveBoard.classList.remove('hidden');
            healthBarDisplay.classList.remove('hidden');
            shopButton.classList.remove('hidden');
            pauseButton.classList.remove('hidden');
            settingsButtonInGame.classList.remove('hidden');
            animationFrameId = requestAnimationFrame(gameLoopWithInput);
        }

        function togglePause() {
            if (gameRunning && !shopOpen && !settingsOpen && !howToPlayOpen) {
                if (paused) resumeGame(); else pauseGame();
            }
        }

        function openShop() {
            wasGameRunningBeforeShop = gameRunning;
            if (gameRunning) { gameRunning = false; cancelAnimationFrame(animationFrameId); animationFrameId = null; }
            if (titleAnimationId) { cancelAnimationFrame(titleAnimationId); titleAnimationId = null; }
            paused = false; settingsOpen = false; howToPlayOpen = false;
            shopOpen = true;
            messageDisplay.style.display = 'none';
            messageDisplay.classList.remove('overlay-message');
            settingsDisplay.style.display = 'none';
            howToPlayDisplay.style.display = 'none';
            shopDisplay.style.display = 'block';
            renderShopItems();
            uiContainer.classList.add('hidden');
            scoreBoard.classList.add('hidden');
            waveBoard.classList.add('hidden');
            healthBarDisplay.classList.add('hidden');
            shopButton.classList.add('hidden');
            pauseButton.classList.add('hidden');
            settingsButtonInGame.classList.add('hidden');
        }

        function closeShop() {
            shopOpen = false;
            shopDisplay.style.display = 'none';
            if (wasGameRunningBeforeShop) {
                gameRunning = true;
                uiContainer.classList.remove('hidden');
                scoreBoard.classList.remove('hidden');
                waveBoard.classList.remove('hidden');
                healthBarDisplay.classList.remove('hidden');
                shopButton.classList.remove('hidden');
                pauseButton.classList.remove('hidden');
                settingsButtonInGame.classList.remove('hidden');
                animationFrameId = requestAnimationFrame(gameLoopWithInput);
            } else {
                startTitleAnimation();
                messageText.textContent = "That Shooting Game";
                messageDisplay.style.display = 'flex';
                startButton.classList.remove('hidden');
                restartButton.classList.add('hidden');
                howToPlayButtonTitle.classList.remove('hidden');
                settingsButtonTitle.classList.remove('hidden');
                messageDisplay.classList.remove('overlay-message');
                isTransitioningFromMenu = true;
                setTimeout(() => { isTransitioningFromMenu = false; }, 200);
            }
        }

        function openSettings() {
            wasGameRunningBeforeSettings = gameRunning;
            if (gameRunning) { gameRunning = false; cancelAnimationFrame(animationFrameId); animationFrameId = null; }
            if (titleAnimationId) { cancelAnimationFrame(titleAnimationId); titleAnimationId = null; }
            paused = false; shopOpen = false; howToPlayOpen = false;
            settingsOpen = true;
            messageDisplay.style.display = 'none';
            shopDisplay.style.display = 'none';
            howToPlayDisplay.style.display = 'none';
            settingsDisplay.style.display = 'block';
            soundToggle.checked = soundEnabled;
            starsToggle.checked = starsEnabled;
            hitboxToggle.checked = showHitboxes;
            touchToggle.checked = touchControlsEnabled; // NEW: sync toggle
            uiContainer.classList.add('hidden');
            scoreBoard.classList.add('hidden');
            waveBoard.classList.add('hidden');
            healthBarDisplay.classList.add('hidden');
            shopButton.classList.add('hidden');
            pauseButton.classList.add('hidden');
            settingsButtonInGame.classList.add('hidden');
            startButton.classList.add('hidden');
            restartButton.classList.add('hidden');
            howToPlayButtonTitle.classList.add('hidden');
            settingsButtonTitle.classList.add('hidden');
        }

        function closeSettings() {
            settingsOpen = false;
            settingsDisplay.style.display = 'none';
            if (wasGameRunningBeforeSettings) {
                gameRunning = true;
                uiContainer.classList.remove('hidden');
                scoreBoard.classList.remove('hidden');
                waveBoard.classList.remove('hidden');
                healthBarDisplay.classList.remove('hidden');
                shopButton.classList.remove('hidden');
                pauseButton.classList.remove('hidden');
                settingsButtonInGame.classList.remove('hidden');
                animationFrameId = requestAnimationFrame(gameLoopWithInput);
            } else {
                startTitleAnimation();
                messageText.textContent = "That Shooting Game";
                messageDisplay.style.display = 'flex';
                startButton.classList.remove('hidden');
                restartButton.classList.add('hidden');
                howToPlayButtonTitle.classList.remove('hidden');
                settingsButtonTitle.classList.remove('hidden');
                isTransitioningFromMenu = true;
                setTimeout(() => { isTransitioningFromMenu = false; }, 200);
            }
        }

        function openHowToPlay() {
            wasGameRunningBeforeHowToPlay = gameRunning;
            if (gameRunning) { gameRunning = false; cancelAnimationFrame(animationFrameId); animationFrameId = null; }
            if (titleAnimationId) { cancelAnimationFrame(titleAnimationId); titleAnimationId = null; }
            paused = false; shopOpen = false; settingsOpen = false;
            howToPlayOpen = true;
            messageDisplay.style.display = 'none';
            shopDisplay.style.display = 'none';
            settingsDisplay.style.display = 'none';
            howToPlayDisplay.style.display = 'block';
            uiContainer.classList.add('hidden');
            scoreBoard.classList.add('hidden');
            waveBoard.classList.add('hidden');
            healthBarDisplay.classList.add('hidden');
            shopButton.classList.add('hidden');
            pauseButton.classList.add('hidden');
            settingsButtonInGame.classList.add('hidden');
            startButton.classList.add('hidden');
            restartButton.classList.add('hidden');
            howToPlayButtonTitle.classList.add('hidden');
            settingsButtonTitle.classList.add('hidden');
        }

        function closeHowToPlay() {
            howToPlayOpen = false;
            howToPlayDisplay.style.display = 'none';
            if (wasGameRunningBeforeHowToPlay) {
                gameRunning = true;
                uiContainer.classList.remove('hidden');
                scoreBoard.classList.remove('hidden');
                waveBoard.classList.remove('hidden');
                healthBarDisplay.classList.remove('hidden');
                shopButton.classList.remove('hidden');
                pauseButton.classList.remove('hidden');
                settingsButtonInGame.classList.remove('hidden');
                animationFrameId = requestAnimationFrame(gameLoopWithInput);
            } else {
                startTitleAnimation();
                messageText.textContent = "That Shooting Game";
                messageDisplay.style.display = 'flex';
                startButton.classList.remove('hidden');
                restartButton.classList.add('hidden');
                howToPlayButtonTitle.classList.remove('hidden');
                settingsButtonTitle.classList.remove('hidden');
                isTransitioningFromMenu = true;
                setTimeout(() => { isTransitioningFromMenu = false; }, 200);
            }
        }

        function renderShopItems() {
            shopItemsContainer.innerHTML = '';
            shopScoreDisplay.textContent = score;
            for (const key in shopItems) {
                const item = shopItems[key];
                const itemCost = item.getCost();
                const itemDisplayName = item.getDisplayName();

                const itemDiv = document.createElement('div');
                itemDiv.className = 'shop-item-button';

                const nameSpan = document.createElement('span');
                nameSpan.textContent = itemDisplayName;
                itemDiv.appendChild(nameSpan);

                const costSpan = document.createElement('span');
                costSpan.textContent = `${itemCost} pts`;
                costSpan.classList.add('font-bold', 'text-yellow-300');
                itemDiv.appendChild(costSpan);

                const buyButton = document.createElement('button');
                buyButton.textContent = 'Buy';
                buyButton.className = 'ml-4 px-4 py-2 bg-green-500 text-white rounded-md hover:bg-green-600 transition-colors';
                buyButton.onclick = () => buyItem(item.id);

                if (item.id === 'healthPack' && playerHealth >= playerMaxHealth) {
                    buyButton.disabled = true;
                    buyButton.classList.remove('hover:bg-green-600');
                    buyButton.classList.add('bg-gray-500', 'cursor-not-allowed');
                } else if (score < itemCost || (item.maxLevel && item.currentLevel >= item.maxLevel)) {
                    buyButton.disabled = true;
                    buyButton.classList.remove('hover:bg-green-600');
                    buyButton.classList.add('bg-gray-500', 'cursor-not-allowed');
                }

                itemDiv.appendChild(buyButton);
                shopItemsContainer.appendChild(itemDiv);
            }
        }

        function buyItem(itemId) {
            const item = shopItems[itemId];
            const itemCost = item.getCost();
            if (score >= itemCost) {
                score -= itemCost;
                updateScoreDisplay();
                item.effect();
                if (item.currentLevel !== undefined) item.currentLevel++;
                renderShopItems();
            } else {
                console.log(`[Shop] Not enough points to buy ${item.name}! Need ${itemCost}, have ${score}.`);
            }
        }

        const keyState = {};
        window.addEventListener('keydown', (e) => {
            keyState[e.key.toLowerCase()] = true;
            if (e.key === ' ' || e.key === 'spacebar') {
                e.preventDefault();
                if (gameRunning && !paused && !shopOpen && !settingsOpen && !howToPlayOpen) shoot();
            } else if (e.key === 'Escape') {
                e.preventDefault();
                if (shopOpen) closeShop();
                else if (settingsOpen) closeSettings();
                else if (howToPlayOpen) closeHowToPlay();
                else togglePause();
            } else if (e.key.toLowerCase() === 'g' && e.ctrlKey) {
                e.preventDefault();
                if (gameRunning && !paused && !shopOpen && !settingsOpen && !howToPlayOpen) window.advanceWave();
            } else if (e.key.toLowerCase() === 'h' && e.ctrlKey) {
                e.preventDefault();
                if (gameRunning && !paused && !shopOpen && !settingsOpen && !howToPlayOpen) {
                    window.addScore(9000);
                    showOverlayMessage("9000 Points Added!");
                }
            }
        });
        window.addEventListener('keyup', (e) => { keyState[e.key.toLowerCase()] = false; });

        window.addEventListener('click', (e) => {
            if (gameRunning && !paused && !shopOpen && !settingsOpen && !howToPlayOpen) shoot();
        });

        // Touch and desktop button controls â€” continuous press behavior
        let touchLeftActive = false;
        let touchRightActive = false;
        let touchUpActive = false;
        let touchDownActive = false;

        // Mouse aiming
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
            mouse.isOverCanvas = true;
        });
        canvas.addEventListener('mouseleave', () => { mouse.isOverCanvas = false; });

        function handleMovementInput() {
            player.dx = 0; player.dy = 0;
            if (keyState['arrowleft'] || keyState['a'] || touchLeftActive) player.dx = -player.speed;
            if (keyState['arrowright'] || keyState['d'] || touchRightActive) player.dx = player.speed;
            if (keyState['arrowup'] || keyState['w'] || touchUpActive) player.dy = -player.speed;
            if (keyState['arrowdown'] || keyState['s'] || touchDownActive) player.dy = player.speed;
        }

        function updatePlayerRotation() {
            const playerCenterX = player.x + player.width / 2;
            const playerCenterY = player.y + player.height / 2;
            if (mouse.isOverCanvas) player.targetAngle = Math.atan2(mouse.y - playerCenterY, mouse.x - playerCenterX);
            else player.targetAngle = -Math.PI / 2;
            player.currentAngle = player.targetAngle;
            player.currentAngle = (player.currentAngle + Math.PI * 2) % (2 * Math.PI);
            if (player.currentAngle > Math.PI) player.currentAngle -= 2 * Math.PI;
        }

        function updateAimIndicator() {
            const playerCenterX = player.x + player.width / 2;
            const playerCenterY = player.y + player.height / 2;
            let mouseTargetX = mouse.isOverCanvas ? mouse.x : playerCenterX;
            let mouseTargetY = mouse.isOverCanvas ? mouse.y : playerCenterY - MAX_AIM_DISTANCE;

            let rawAngleToMouse = Math.atan2(mouseTargetY - playerCenterY, mouseTargetX - playerCenterX);
            let angleDiffFromPlayer = rawAngleToMouse - player.currentAngle;
            if (angleDiffFromPlayer > Math.PI) angleDiffFromPlayer -= 2 * Math.PI;
            if (angleDiffFromPlayer < -Math.PI) angleDiffFromPlayer += 2 * Math.PI;
            let clampedAngleDiff = Math.max(-MAX_AIM_ANGLE_RADIANS, Math.min(MAX_AIM_ANGLE_RADIANS, angleDiffFromPlayer));
            let actualAimAngle = player.currentAngle + clampedAngleDiff;

            let distanceToMouse = Math.sqrt((mouseTargetX - playerCenterX)**2 + (mouseTargetY - playerCenterY)**2);
            let finalDistance = Math.min(distanceToMouse, MAX_AIM_DISTANCE);

            aimIndicator.x = playerCenterX + finalDistance * Math.cos(actualAimAngle);
            aimIndicator.y = playerCenterY + finalDistance * Math.sin(actualAimAngle);
        }

        function gameLoopWithInput() {
            if (!gameRunning || shopOpen || paused || settingsOpen || howToPlayOpen) {
                if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
                return;
            }
            ctx.fillStyle = '#000'; ctx.fillRect(0, 0, gameWidth, gameHeight);

            handleMovementInput();
            updatePlayerRotation();
            updateAimIndicator();

            updateStars();
            drawStars();

            updatePlayer();
            drawPlayer();
            drawPlayerHitbox();
            aimIndicator.draw();

            if (bossActive) {
                updateBoss(); boss.draw();
            } else {
                spawnEnemy();
                updateEnemies();
                enemies.forEach(enemy => drawGenericEnemy(enemy));
            }

            updateBullets();
            bullets.forEach(drawBullet);

            updateEnemyBullets();
            enemyBullets.forEach(bullet => enemyBulletProps.draw(bullet));

            checkCollisions();

            if (flashEffect.active) {
                ctx.fillStyle = flashEffect.color; ctx.fillRect(0, 0, gameWidth, gameHeight);
                if (Date.now() - flashEffect.startTime > flashEffect.duration) flashEffect.active = false;
            }

            animationFrameId = requestAnimationFrame(gameLoopWithInput);
        }

        function updateTitleScreenPlayer() {
            player.titleAnimationOffset += player.titleAnimationDirection * player.titleAnimationSpeed;
            if (player.titleAnimationOffset > player.titleAnimationMaxOffset || player.titleAnimationOffset < -player.titleAnimationMaxOffset) {
                player.titleAnimationDirection *= -1;
            }
            player.y = player.initialY + player.titleAnimationOffset;
        }

        function titleScreenAnimationLoop() {
            if (gameRunning || shopOpen || settingsOpen || howToPlayOpen) {
                cancelAnimationFrame(titleAnimationId); titleAnimationId = null; return;
            }
            ctx.fillStyle = '#000'; ctx.fillRect(0, 0, gameWidth, gameHeight);
            updateStars(); drawStars();
            updateTitleScreenPlayer(); drawPlayer();
            titleAnimationId = requestAnimationFrame(titleScreenAnimationLoop);
        }

        function startTitleAnimation() {
            if (!titleAnimationId) {
                player.y = player.initialY;
                player.titleAnimationOffset = 0;
                player.titleAnimationDirection = 1;
                titleAnimationId = requestAnimationFrame(titleScreenAnimationLoop);
                console.log("[Title Animation] Title animation started.");
            }
        }

        // Touch buttons: add both touch and mouse for desktop testing
        function bindPressHold(btn, onDown, onUp) {
            // Touch
            btn.addEventListener('touchstart', (e) => { e.preventDefault(); onDown(); });
            btn.addEventListener('touchend', (e) => { e.preventDefault(); onUp(); });
            btn.addEventListener('touchcancel', (e) => { e.preventDefault(); onUp(); });
            // Mouse (desktop)
            btn.addEventListener('mousedown', (e) => { e.preventDefault(); onDown(); });
            btn.addEventListener('mouseup', (e) => { e.preventDefault(); onUp(); });
            btn.addEventListener('mouseleave', (e) => { e.preventDefault(); onUp(); });
        }

        bindPressHold(touchLeftBtn, () => { touchLeftActive = true; }, () => { touchLeftActive = false; });
        bindPressHold(touchRightBtn, () => { touchRightActive = true; }, () => { touchRightActive = false; });
        bindPressHold(touchShootBtn, () => {
            if (gameRunning && !paused && !shopOpen && !settingsOpen && !howToPlayOpen) shoot();
        }, () => { /* no hold needed for shooting */ });

        // Create and append vertical touch buttons (Up/Down)
        const touchUpBtn = document.createElement('button');
        touchUpBtn.id = 'touchUpBtn'; touchUpBtn.textContent = 'â–²';
        const touchDownBtn = document.createElement('button');
        touchDownBtn.id = 'touchDownBtn'; touchDownBtn.textContent = 'â–¼';

        // Style reuse via class
        touchUpBtn.classList.add('touch-control-vertical');
        touchDownBtn.classList.add('touch-control-vertical');

        document.querySelector('.touch-controls').insertBefore(touchUpBtn, touchShootBtn);
        document.querySelector('.touch-controls').insertBefore(touchDownBtn, touchShootBtn.nextSibling);

        // Add styling for vertical touch buttons (similar to existing touch buttons)
        const styleSheet = document.createElement("style");
        styleSheet.type = "text/css";
        styleSheet.innerText = `
            .touch-control-vertical {
                background: linear-gradient(to bottom, #4a5568, #2d3748);
                color: white;
                border: 2px solid #a0aec0;
                border-radius: 50%;
                width: 72px; height: 72px;
                font-size: 28px;
                display: flex; align-items: center; justify-content: center;
                user-select: none; -webkit-user-select: none; -ms-user-select: none;
                box-shadow: 0 6px 10px rgba(0,0,0,0.4);
                transition: transform 0.08s ease-out, opacity 0.08s ease-out;
                text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
                opacity: 0.95;
            }
            .touch-control-vertical:active { transform: scale(0.92); opacity: 0.85; }
        `;
        document.head.appendChild(styleSheet);

        // Bind up/down continuous movement
        bindPressHold(touchUpBtn, () => { touchUpActive = true; }, () => { touchUpActive = false; });
        bindPressHold(touchDownBtn, () => { touchDownActive = true; }, () => { touchDownActive = false; });

        // UI events
        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', startGame);
        shopButton.addEventListener('click', openShop);
        closeShopBtn.addEventListener('click', closeShop);
        pauseButton.addEventListener('click', togglePause);
        settingsButtonTitle.addEventListener('click', openSettings);
        settingsButtonInGame.addEventListener('click', openSettings);
        closeSettingsBtn.addEventListener('click', closeSettings);
        soundToggle.addEventListener('change', toggleSound);
        starsToggle.addEventListener('change', toggleStars);
        hitboxToggle.addEventListener('change', toggleHitboxes);
        howToPlayButtonTitle.addEventListener('click', openHowToPlay);
        closeHowToPlayBtn.addEventListener('click', closeHowToPlay);
        touchToggle.addEventListener('change', toggleTouchControls);

        window.addEventListener('resize', () => {
            resizeCanvas();
            if (!gameRunning && !shopOpen && !settingsOpen && !howToPlayOpen) startTitleAnimation();
            if (shopOpen) renderShopItems();
        });

        window.onload = () => {
            console.log("Window loaded. Initializing game.");
            Tone.start().then(() => {
                console.log("Audio context started successfully!");
            }).catch(e => {
                console.error("Error starting audio context:", e);
            });

            resizeCanvas();
            updateScoreDisplay();
            updateHealthDisplay();
            initializeStars();

            messageText.textContent = "That Shooting Game";
            messageDisplay.style.display = 'flex';
            startButton.classList.remove('hidden');
            restartButton.classList.add('hidden');
            howToPlayButtonTitle.classList.remove('hidden');
            settingsButtonTitle.classList.remove('hidden');

            scoreBoard.classList.add('hidden');
            waveBoard.classList.add('hidden');
            healthBarDisplay.classList.add('hidden');
            shopButton.classList.add('hidden');
            pauseButton.classList.add('hidden');
            settingsButtonInGame.classList.add('hidden');
            shopDisplay.style.display = 'none';
            settingsDisplay.style.display = 'none';
            howToPlayDisplay.style.display = 'none';

            // Initialize toggle states
            soundToggle.checked = soundEnabled;
            Tone.Master.mute = !soundEnabled;
            starsToggle.checked = starsEnabled;
            hitboxToggle.checked = showHitboxes;

            // Touch controls: default OFF for desktop testing; mobile shows via media query but can be forced here
            touchToggle.checked = touchControlsEnabled;
            applyTouchControlsVisibility();

            startTitleAnimation();
            console.log("Window onload finished. gameRunning:", gameRunning);
        };

        // --- Console Commands for Playtesting ---
        window.advanceWave = function() {
            if (!gameRunning) { console.warn("Game is not running. Start the game before advancing waves."); return; }
            if (bossActive) {
                defeatBoss();
                console.log(`[Console Command] Boss defeated! Advancing to Wave ${wave}.`);
            } else {
                enemiesDefeatedInWave = enemiesRequiredForWave;
                if (!bossActive && enemiesDefeatedInWave >= enemiesRequiredForWave) {
                    wave++;
                    enemiesDefeatedInWave = 0;
                    enemyProps.spawnInterval = Math.max(50, baseSpawnInterval - ((wave - 1) % wavesPerBoss) * spawnIntervalDecreasePerWave);
                    updateScoreDisplay();
                    showOverlayMessage(`Wave ${wave} Incoming!`);
                    if ((wave - 1) % wavesPerBoss === 0 && wave > 1) {
                        enemies.length = 0;
                        startBossFight();
                    }
                }
                console.log(`[Console Command] Advanced to Wave ${wave}.`);
            }
            enemies.length = 0;
            enemyBullets.length = 0;
        };

        window.addScore = function(amount) {
            if (typeof amount !== 'number' || amount <= 0) { console.warn("Please provide a positive number for the score amount."); return; }
            score += amount; updateScoreDisplay();
            console.log(`[Console Command] Added ${amount} score. Current score: ${score}`);
        };

        window.fullHeal = function() {
            playerHealth = playerMaxHealth; updateHealthDisplay();
            console.log("[Console Command] Player health fully restored!");
        };
    </script>
</body>
</html>
